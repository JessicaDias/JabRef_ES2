


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: BasePanel</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">net.sf.jabref.gui</a> ]
</div>

<h1>Coverage Summary for Class: BasePanel (net.sf.jabref.gui)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BasePanel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 136)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 898)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BasePanel$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$AutoCompleteListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$GroupTreeListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$GroupTreeListener$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$GroupTreeListener$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$GroupTreeListener$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$OpenURLAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$PrintPreviewAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$RedoAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$SaveSelectedAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$SearchAndOpenFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$SearchAutoCompleteListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$SearchListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasePanel$UndoAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 184)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1181)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;package net.sf.jabref.gui;
<i>2</i>&nbsp;
<i>3</i>&nbsp;import java.awt.BorderLayout;
<i>4</i>&nbsp;import java.awt.Toolkit;
<i>5</i>&nbsp;import java.awt.datatransfer.Clipboard;
<i>6</i>&nbsp;import java.awt.datatransfer.ClipboardOwner;
<i>7</i>&nbsp;import java.awt.datatransfer.StringSelection;
<i>8</i>&nbsp;import java.awt.datatransfer.Transferable;
<i>9</i>&nbsp;import java.awt.event.ActionEvent;
<i>10</i>&nbsp;import java.awt.event.KeyAdapter;
<i>11</i>&nbsp;import java.awt.event.KeyEvent;
<i>12</i>&nbsp;import java.io.File;
<i>13</i>&nbsp;import java.io.IOException;
<i>14</i>&nbsp;import java.io.StringReader;
<i>15</i>&nbsp;import java.lang.reflect.InvocationTargetException;
<i>16</i>&nbsp;import java.nio.charset.Charset;
<i>17</i>&nbsp;import java.nio.charset.UnsupportedCharsetException;
<i>18</i>&nbsp;import java.nio.file.Path;
<i>19</i>&nbsp;import java.util.ArrayList;
<i>20</i>&nbsp;import java.util.Collection;
<i>21</i>&nbsp;import java.util.Collections;
<i>22</i>&nbsp;import java.util.HashMap;
<i>23</i>&nbsp;import java.util.List;
<i>24</i>&nbsp;import java.util.Map;
<i>25</i>&nbsp;import java.util.Objects;
<i>26</i>&nbsp;import java.util.Optional;
<i>27</i>&nbsp;import java.util.Set;
<i>28</i>&nbsp;import java.util.TimerTask;
<i>29</i>&nbsp;
<i>30</i>&nbsp;import javax.swing.AbstractAction;
<i>31</i>&nbsp;import javax.swing.BorderFactory;
<i>32</i>&nbsp;import javax.swing.JComponent;
<i>33</i>&nbsp;import javax.swing.JOptionPane;
<i>34</i>&nbsp;import javax.swing.JPanel;
<i>35</i>&nbsp;import javax.swing.JSplitPane;
<i>36</i>&nbsp;import javax.swing.JTextArea;
<i>37</i>&nbsp;import javax.swing.SwingUtilities;
<i>38</i>&nbsp;import javax.swing.tree.TreePath;
<i>39</i>&nbsp;import javax.swing.undo.CannotRedoException;
<i>40</i>&nbsp;import javax.swing.undo.CannotUndoException;
<i>41</i>&nbsp;
<i>42</i>&nbsp;import net.sf.jabref.Globals;
<i>43</i>&nbsp;import net.sf.jabref.JabRefExecutorService;
<i>44</i>&nbsp;import net.sf.jabref.collab.ChangeScanner;
<i>45</i>&nbsp;import net.sf.jabref.collab.FileUpdateListener;
<i>46</i>&nbsp;import net.sf.jabref.collab.FileUpdatePanel;
<i>47</i>&nbsp;import net.sf.jabref.gui.actions.Actions;
<i>48</i>&nbsp;import net.sf.jabref.gui.actions.BaseAction;
<i>49</i>&nbsp;import net.sf.jabref.gui.actions.CleanupAction;
<i>50</i>&nbsp;import net.sf.jabref.gui.actions.CopyBibTeXKeyAndLinkAction;
<i>51</i>&nbsp;import net.sf.jabref.gui.bibtexkeypattern.SearchFixDuplicateLabels;
<i>52</i>&nbsp;import net.sf.jabref.gui.contentselector.ContentSelectorDialog;
<i>53</i>&nbsp;import net.sf.jabref.gui.desktop.JabRefDesktop;
<i>54</i>&nbsp;import net.sf.jabref.gui.entryeditor.EntryEditor;
<i>55</i>&nbsp;import net.sf.jabref.gui.exporter.ExportToClipboardAction;
<i>56</i>&nbsp;import net.sf.jabref.gui.exporter.SaveDatabaseAction;
<i>57</i>&nbsp;import net.sf.jabref.gui.externalfiles.FindFullTextAction;
<i>58</i>&nbsp;import net.sf.jabref.gui.externalfiles.SynchronizeFileField;
<i>59</i>&nbsp;import net.sf.jabref.gui.externalfiles.WriteXMPAction;
<i>60</i>&nbsp;import net.sf.jabref.gui.externalfiletype.ExternalFileMenuItem;
<i>61</i>&nbsp;import net.sf.jabref.gui.externalfiletype.ExternalFileType;
<i>62</i>&nbsp;import net.sf.jabref.gui.externalfiletype.ExternalFileTypes;
<i>63</i>&nbsp;import net.sf.jabref.gui.fieldeditors.FieldEditor;
<i>64</i>&nbsp;import net.sf.jabref.gui.filelist.AttachFileAction;
<i>65</i>&nbsp;import net.sf.jabref.gui.filelist.FileListEntry;
<i>66</i>&nbsp;import net.sf.jabref.gui.filelist.FileListTableModel;
<i>67</i>&nbsp;import net.sf.jabref.gui.groups.GroupAddRemoveDialog;
<i>68</i>&nbsp;import net.sf.jabref.gui.groups.GroupSelector;
<i>69</i>&nbsp;import net.sf.jabref.gui.groups.GroupTreeNodeViewModel;
<i>70</i>&nbsp;import net.sf.jabref.gui.importer.actions.AppendDatabaseAction;
<i>71</i>&nbsp;import net.sf.jabref.gui.journals.AbbreviateAction;
<i>72</i>&nbsp;import net.sf.jabref.gui.journals.UnabbreviateAction;
<i>73</i>&nbsp;import net.sf.jabref.gui.keyboard.KeyBinding;
<i>74</i>&nbsp;import net.sf.jabref.gui.maintable.MainTable;
<i>75</i>&nbsp;import net.sf.jabref.gui.maintable.MainTableDataModel;
<i>76</i>&nbsp;import net.sf.jabref.gui.maintable.MainTableFormat;
<i>77</i>&nbsp;import net.sf.jabref.gui.maintable.MainTableSelectionListener;
<i>78</i>&nbsp;import net.sf.jabref.gui.mergeentries.MergeEntriesDialog;
<i>79</i>&nbsp;import net.sf.jabref.gui.mergeentries.MergeWithFetchedEntryAction;
<i>80</i>&nbsp;import net.sf.jabref.gui.plaintextimport.TextInputDialog;
<i>81</i>&nbsp;import net.sf.jabref.gui.specialfields.SpecialFieldDatabaseChangeListener;
<i>82</i>&nbsp;import net.sf.jabref.gui.specialfields.SpecialFieldValueViewModel;
<i>83</i>&nbsp;import net.sf.jabref.gui.specialfields.SpecialFieldViewModel;
<i>84</i>&nbsp;import net.sf.jabref.gui.undo.CountingUndoManager;
<i>85</i>&nbsp;import net.sf.jabref.gui.undo.NamedCompound;
<i>86</i>&nbsp;import net.sf.jabref.gui.undo.UndoableChangeType;
<i>87</i>&nbsp;import net.sf.jabref.gui.undo.UndoableFieldChange;
<i>88</i>&nbsp;import net.sf.jabref.gui.undo.UndoableInsertEntry;
<i>89</i>&nbsp;import net.sf.jabref.gui.undo.UndoableKeyChange;
<i>90</i>&nbsp;import net.sf.jabref.gui.undo.UndoableRemoveEntry;
<i>91</i>&nbsp;import net.sf.jabref.gui.util.component.CheckBoxMessage;
<i>92</i>&nbsp;import net.sf.jabref.gui.worker.AbstractWorker;
<i>93</i>&nbsp;import net.sf.jabref.gui.worker.CallBack;
<i>94</i>&nbsp;import net.sf.jabref.gui.worker.CitationStyleToClipboardWorker;
<i>95</i>&nbsp;import net.sf.jabref.gui.worker.MarkEntriesAction;
<i>96</i>&nbsp;import net.sf.jabref.gui.worker.SendAsEMailAction;
<i>97</i>&nbsp;import net.sf.jabref.logic.autocompleter.AutoCompletePreferences;
<i>98</i>&nbsp;import net.sf.jabref.logic.autocompleter.AutoCompleter;
<i>99</i>&nbsp;import net.sf.jabref.logic.autocompleter.AutoCompleterFactory;
<i>100</i>&nbsp;import net.sf.jabref.logic.autocompleter.ContentAutoCompleters;
<i>101</i>&nbsp;import net.sf.jabref.logic.bibtexkeypattern.BibtexKeyPatternUtil;
<i>102</i>&nbsp;import net.sf.jabref.logic.citationstyle.CitationStyleCache;
<i>103</i>&nbsp;import net.sf.jabref.logic.citationstyle.CitationStyleOutputFormat;
<i>104</i>&nbsp;import net.sf.jabref.logic.exporter.BibtexDatabaseWriter;
<i>105</i>&nbsp;import net.sf.jabref.logic.exporter.FileSaveSession;
<i>106</i>&nbsp;import net.sf.jabref.logic.exporter.SaveException;
<i>107</i>&nbsp;import net.sf.jabref.logic.exporter.SavePreferences;
<i>108</i>&nbsp;import net.sf.jabref.logic.exporter.SaveSession;
<i>109</i>&nbsp;import net.sf.jabref.logic.l10n.Encodings;
<i>110</i>&nbsp;import net.sf.jabref.logic.l10n.Localization;
<i>111</i>&nbsp;import net.sf.jabref.logic.layout.Layout;
<i>112</i>&nbsp;import net.sf.jabref.logic.layout.LayoutHelper;
<i>113</i>&nbsp;import net.sf.jabref.logic.search.SearchQuery;
<i>114</i>&nbsp;import net.sf.jabref.logic.util.FileExtensions;
<i>115</i>&nbsp;import net.sf.jabref.logic.util.UpdateField;
<i>116</i>&nbsp;import net.sf.jabref.logic.util.io.FileBasedLock;
<i>117</i>&nbsp;import net.sf.jabref.logic.util.io.FileUtil;
<i>118</i>&nbsp;import net.sf.jabref.logic.util.io.RegExpFileSearch;
<i>119</i>&nbsp;import net.sf.jabref.model.FieldChange;
<i>120</i>&nbsp;import net.sf.jabref.model.bibtexkeypattern.AbstractBibtexKeyPattern;
<i>121</i>&nbsp;import net.sf.jabref.model.database.BibDatabase;
<i>122</i>&nbsp;import net.sf.jabref.model.database.BibDatabaseContext;
<i>123</i>&nbsp;import net.sf.jabref.model.database.DatabaseLocation;
<i>124</i>&nbsp;import net.sf.jabref.model.database.KeyCollisionException;
<i>125</i>&nbsp;import net.sf.jabref.model.database.event.EntryAddedEvent;
<i>126</i>&nbsp;import net.sf.jabref.model.database.event.EntryRemovedEvent;
<i>127</i>&nbsp;import net.sf.jabref.model.entry.BibEntry;
<i>128</i>&nbsp;import net.sf.jabref.model.entry.EntryType;
<i>129</i>&nbsp;import net.sf.jabref.model.entry.FieldName;
<i>130</i>&nbsp;import net.sf.jabref.model.entry.event.EntryChangedEvent;
<i>131</i>&nbsp;import net.sf.jabref.model.entry.event.EntryEventSource;
<i>132</i>&nbsp;import net.sf.jabref.model.entry.specialfields.SpecialField;
<i>133</i>&nbsp;import net.sf.jabref.model.entry.specialfields.SpecialFieldValue;
<i>134</i>&nbsp;import net.sf.jabref.preferences.HighlightMatchingGroupPreferences;
<i>135</i>&nbsp;import net.sf.jabref.preferences.JabRefPreferences;
<i>136</i>&nbsp;import net.sf.jabref.preferences.PreviewPreferences;
<i>137</i>&nbsp;import net.sf.jabref.shared.DBMSSynchronizer;
<i>138</i>&nbsp;
<i>139</i>&nbsp;import ca.odell.glazedlists.event.ListEventListener;
<i>140</i>&nbsp;import com.google.common.eventbus.Subscribe;
<i>141</i>&nbsp;import com.jgoodies.forms.builder.FormBuilder;
<i>142</i>&nbsp;import com.jgoodies.forms.layout.FormLayout;
<i>143</i>&nbsp;import org.apache.commons.logging.Log;
<i>144</i>&nbsp;import org.apache.commons.logging.LogFactory;
<i>145</i>&nbsp;
<i>146</i>&nbsp;public class BasePanel extends JPanel implements ClipboardOwner, FileUpdateListener {
<b class="nc"><i>147</i>&nbsp;    private static final Log LOGGER = LogFactory.getLog(BasePanel.class);</b>
<i>148</i>&nbsp;
<i>149</i>&nbsp;    // Divider size for BaseFrame split pane. 0 means non-resizable.
<i>150</i>&nbsp;    private static final int SPLIT_PANE_DIVIDER_SIZE = 4;
<i>151</i>&nbsp;
<i>152</i>&nbsp;    private final BibDatabaseContext bibDatabaseContext;
<i>153</i>&nbsp;    private final MainTableDataModel tableModel;
<i>154</i>&nbsp;
<i>155</i>&nbsp;    private final CitationStyleCache citationStyleCache;
<i>156</i>&nbsp;
<i>157</i>&nbsp;    // To contain instantiated entry editors. This is to save time
<i>158</i>&nbsp;    // As most enums, this must not be null
<b class="nc"><i>159</i>&nbsp;    private BasePanelMode mode = BasePanelMode.SHOWING_NOTHING;</b>
<i>160</i>&nbsp;    private EntryEditor currentEditor;
<i>161</i>&nbsp;
<i>162</i>&nbsp;    private MainTableSelectionListener selectionListener;
<i>163</i>&nbsp;
<i>164</i>&nbsp;    private ListEventListener&lt;BibEntry&gt; groupsHighlightListener;
<i>165</i>&nbsp;
<i>166</i>&nbsp;    private JSplitPane splitPane;
<i>167</i>&nbsp;
<i>168</i>&nbsp;    private final JabRefFrame frame;
<i>169</i>&nbsp;    private String fileMonitorHandle;
<i>170</i>&nbsp;    private boolean saving;
<i>171</i>&nbsp;    private boolean updatedExternally;
<i>172</i>&nbsp;
<i>173</i>&nbsp;    // AutoCompleter used in the search bar
<i>174</i>&nbsp;    private AutoCompleter&lt;String&gt; searchAutoCompleter;
<i>175</i>&nbsp;    // The undo manager.
<b class="nc"><i>176</i>&nbsp;    private final UndoAction undoAction = new UndoAction();</b>
<b class="nc"><i>177</i>&nbsp;    private final RedoAction redoAction = new RedoAction();</b>
<b class="nc"><i>178</i>&nbsp;    private final CountingUndoManager undoManager = new CountingUndoManager();</b>
<i>179</i>&nbsp;
<b class="nc"><i>180</i>&nbsp;    private final List&lt;BibEntry&gt; previousEntries = new ArrayList&lt;&gt;();</b>
<i>181</i>&nbsp;
<b class="nc"><i>182</i>&nbsp;    private final List&lt;BibEntry&gt; nextEntries = new ArrayList&lt;&gt;();</b>
<i>183</i>&nbsp;    private boolean baseChanged;
<i>184</i>&nbsp;    private boolean nonUndoableChange;
<i>185</i>&nbsp;
<i>186</i>&nbsp;    // Used to track whether the base has changed since last save.
<i>187</i>&nbsp;    private MainTable mainTable;
<i>188</i>&nbsp;
<i>189</i>&nbsp;    private MainTableFormat tableFormat;
<i>190</i>&nbsp;
<i>191</i>&nbsp;    private BibEntry showing;
<i>192</i>&nbsp;
<i>193</i>&nbsp;    // Variable to prevent erroneous update of back/forward histories at the time
<i>194</i>&nbsp;    // when a Back or Forward operation is being processed:
<i>195</i>&nbsp;    private boolean backOrForwardInProgress;
<i>196</i>&nbsp;
<i>197</i>&nbsp;    // in switching between entries.
<i>198</i>&nbsp;    private PreambleEditor preambleEditor;
<i>199</i>&nbsp;
<i>200</i>&nbsp;    // Keeps track of the preamble dialog if it is open.
<i>201</i>&nbsp;    private StringDialog stringDialog;
<i>202</i>&nbsp;
<i>203</i>&nbsp;    // Keeps track of the string dialog if it is open.
<b class="nc"><i>204</i>&nbsp;    private final Map&lt;String, Object&gt; actions = new HashMap&lt;&gt;();</b>
<i>205</i>&nbsp;
<i>206</i>&nbsp;    private final SidePaneManager sidePaneManager;
<i>207</i>&nbsp;
<i>208</i>&nbsp;    private ContentAutoCompleters autoCompleters;
<i>209</i>&nbsp;
<i>210</i>&nbsp;    /** the query the user searches when this basepanel is active */
<b class="nc"><i>211</i>&nbsp;    private Optional&lt;SearchQuery&gt; currentSearchQuery = Optional.empty();</b>
<i>212</i>&nbsp;
<i>213</i>&nbsp;
<b class="nc"><i>214</i>&nbsp;    public BasePanel(JabRefFrame frame, BibDatabaseContext bibDatabaseContext) {</b>
<b class="nc"><i>215</i>&nbsp;        Objects.requireNonNull(frame);</b>
<b class="nc"><i>216</i>&nbsp;        Objects.requireNonNull(bibDatabaseContext);</b>
<i>217</i>&nbsp;
<b class="nc"><i>218</i>&nbsp;        this.bibDatabaseContext = bibDatabaseContext;</b>
<i>219</i>&nbsp;
<b class="nc"><i>220</i>&nbsp;        this.sidePaneManager = frame.getSidePaneManager();</b>
<b class="nc"><i>221</i>&nbsp;        this.frame = frame;</b>
<b class="nc"><i>222</i>&nbsp;        this.tableModel = new MainTableDataModel(getBibDatabaseContext());</b>
<i>223</i>&nbsp;
<b class="nc"><i>224</i>&nbsp;        citationStyleCache = new CitationStyleCache(bibDatabaseContext);</b>
<i>225</i>&nbsp;
<b class="nc"><i>226</i>&nbsp;        setupMainPanel();</b>
<i>227</i>&nbsp;
<b class="nc"><i>228</i>&nbsp;        setupActions();</b>
<i>229</i>&nbsp;
<b class="nc"><i>230</i>&nbsp;        this.getDatabase().registerListener(new SearchListener());</b>
<i>231</i>&nbsp;
<i>232</i>&nbsp;        // ensure that at each addition of a new entry, the entry is added to the groups interface
<b class="nc"><i>233</i>&nbsp;        this.bibDatabaseContext.getDatabase().registerListener(new GroupTreeListener());</b>
<i>234</i>&nbsp;
<b class="nc"><i>235</i>&nbsp;        Optional&lt;File&gt; file = bibDatabaseContext.getDatabaseFile();</b>
<b class="nc"><i>236</i>&nbsp;        if (file.isPresent()) {</b>
<i>237</i>&nbsp;            // Register so we get notifications about outside changes to the file.
<i>238</i>&nbsp;            try {
<b class="nc"><i>239</i>&nbsp;                fileMonitorHandle = Globals.getFileUpdateMonitor().addUpdateListener(this, file.get());</b>
<b class="nc"><i>240</i>&nbsp;            } catch (IOException ex) {</b>
<b class="nc"><i>241</i>&nbsp;                LOGGER.warn(&quot;Could not register FileUpdateMonitor&quot;, ex);</b>
<b class="nc"><i>242</i>&nbsp;            }</b>
<i>243</i>&nbsp;        } else {
<b class="nc"><i>244</i>&nbsp;            if (bibDatabaseContext.getDatabase().hasEntries()) {</b>
<i>245</i>&nbsp;                // if the database is not empty and no file is assigned,
<i>246</i>&nbsp;                // the database came from an import and has to be treated somehow
<i>247</i>&nbsp;                // -&gt; mark as changed
<b class="nc"><i>248</i>&nbsp;                this.baseChanged = true;</b>
<i>249</i>&nbsp;            }
<i>250</i>&nbsp;        }
<b class="nc"><i>251</i>&nbsp;    }</b>
<i>252</i>&nbsp;
<i>253</i>&nbsp;    // Returns a collection of AutoCompleters, which are populated from the current database
<i>254</i>&nbsp;    public ContentAutoCompleters getAutoCompleters() {
<b class="nc"><i>255</i>&nbsp;        return autoCompleters;</b>
<i>256</i>&nbsp;    }
<i>257</i>&nbsp;
<i>258</i>&nbsp;    public String getTabTitle() {
<b class="nc"><i>259</i>&nbsp;        StringBuilder title = new StringBuilder();</b>
<b class="nc"><i>260</i>&nbsp;        DatabaseLocation databaseLocation = this.bibDatabaseContext.getLocation();</b>
<b class="nc"><i>261</i>&nbsp;        boolean isAutosaveEnabled = Globals.prefs.getBoolean(JabRefPreferences.LOCAL_AUTO_SAVE);</b>
<i>262</i>&nbsp;
<b class="nc"><i>263</i>&nbsp;        if (databaseLocation == DatabaseLocation.LOCAL) {</b>
<b class="nc"><i>264</i>&nbsp;            if (this.bibDatabaseContext.getDatabaseFile().isPresent()) {</b>
<i>265</i>&nbsp;                // check if file is modified
<b class="nc"><i>266</i>&nbsp;                String changeFlag = isModified() &amp;&amp; !isAutosaveEnabled ? &quot;*&quot; : &quot;&quot;;</b>
<b class="nc"><i>267</i>&nbsp;                title.append(this.bibDatabaseContext.getDatabaseFile().get().getName()).append(changeFlag);</b>
<b class="nc"><i>268</i>&nbsp;            } else {</b>
<b class="nc"><i>269</i>&nbsp;                title.append(GUIGlobals.UNTITLED_TITLE);</b>
<i>270</i>&nbsp;
<b class="nc"><i>271</i>&nbsp;                if (getDatabase().hasEntries()) {</b>
<i>272</i>&nbsp;                    // if the database is not empty and no file is assigned,
<i>273</i>&nbsp;                    // the database came from an import and has to be treated somehow
<i>274</i>&nbsp;                    // -&gt; mark as changed
<i>275</i>&nbsp;                    // This also happens internally at basepanel to ensure consistency line 224
<b class="nc"><i>276</i>&nbsp;                    title.append(&#39;*&#39;);</b>
<i>277</i>&nbsp;                }
<i>278</i>&nbsp;            }
<b class="nc"><i>279</i>&nbsp;        } else if (databaseLocation == DatabaseLocation.SHARED) {</b>
<b class="nc"><i>280</i>&nbsp;            title.append(</b>
<b class="nc"><i>281</i>&nbsp;                    this.bibDatabaseContext.getDBMSSynchronizer().getDBName() + &quot; [&quot; + Localization.lang(&quot;shared&quot;) + &quot;]&quot;);</b>
<i>282</i>&nbsp;        }
<i>283</i>&nbsp;
<b class="nc"><i>284</i>&nbsp;        return title.toString();</b>
<i>285</i>&nbsp;    }
<i>286</i>&nbsp;
<i>287</i>&nbsp;    public boolean isModified() {
<b class="nc"><i>288</i>&nbsp;        return baseChanged;</b>
<i>289</i>&nbsp;    }
<i>290</i>&nbsp;
<i>291</i>&nbsp;    public BasePanelMode getMode() {
<b class="nc"><i>292</i>&nbsp;        return mode;</b>
<i>293</i>&nbsp;    }
<i>294</i>&nbsp;
<i>295</i>&nbsp;    public void setMode(BasePanelMode mode) {
<b class="nc"><i>296</i>&nbsp;        this.mode = mode;</b>
<b class="nc"><i>297</i>&nbsp;    }</b>
<i>298</i>&nbsp;
<i>299</i>&nbsp;    public JabRefFrame frame() {
<b class="nc"><i>300</i>&nbsp;        return frame;</b>
<i>301</i>&nbsp;    }
<i>302</i>&nbsp;
<i>303</i>&nbsp;    public void output(String s) {
<b class="nc"><i>304</i>&nbsp;        frame.output(s);</b>
<b class="nc"><i>305</i>&nbsp;    }</b>
<i>306</i>&nbsp;
<i>307</i>&nbsp;    private void setupActions() {
<b class="nc"><i>308</i>&nbsp;        SaveDatabaseAction saveAction = new SaveDatabaseAction(this);</b>
<b class="nc"><i>309</i>&nbsp;        CleanupAction cleanUpAction = new CleanupAction(this, Globals.prefs);</b>
<i>310</i>&nbsp;
<b class="nc"><i>311</i>&nbsp;        actions.put(Actions.UNDO, undoAction);</b>
<b class="nc"><i>312</i>&nbsp;        actions.put(Actions.REDO, redoAction);</b>
<i>313</i>&nbsp;
<b class="nc"><i>314</i>&nbsp;        actions.put(Actions.FOCUS_TABLE, (BaseAction) () -&gt; {</b>
<b class="nc"><i>315</i>&nbsp;            mainTable.requestFocus();</b>
<b class="nc"><i>316</i>&nbsp;        });</b>
<i>317</i>&nbsp;
<i>318</i>&nbsp;        // The action for opening an entry editor.
<b class="nc"><i>319</i>&nbsp;        actions.put(Actions.EDIT, (BaseAction) selectionListener::editSignalled);</b>
<i>320</i>&nbsp;
<i>321</i>&nbsp;        // The action for saving a database.
<b class="nc"><i>322</i>&nbsp;        actions.put(Actions.SAVE, saveAction);</b>
<i>323</i>&nbsp;
<b class="nc"><i>324</i>&nbsp;        actions.put(Actions.SAVE_AS, (BaseAction) saveAction::saveAs);</b>
<i>325</i>&nbsp;
<b class="nc"><i>326</i>&nbsp;        actions.put(Actions.SAVE_SELECTED_AS, new SaveSelectedAction(SavePreferences.DatabaseSaveType.ALL));</b>
<i>327</i>&nbsp;
<b class="nc"><i>328</i>&nbsp;        actions.put(Actions.SAVE_SELECTED_AS_PLAIN,</b>
<i>329</i>&nbsp;                new SaveSelectedAction(SavePreferences.DatabaseSaveType.PLAIN_BIBTEX));
<i>330</i>&nbsp;
<i>331</i>&nbsp;        // The action for copying selected entries.
<b class="nc"><i>332</i>&nbsp;        actions.put(Actions.COPY, (BaseAction) () -&gt; copy());</b>
<i>333</i>&nbsp;
<b class="nc"><i>334</i>&nbsp;        actions.put(Actions.PRINT_PREVIEW, new PrintPreviewAction());</b>
<i>335</i>&nbsp;
<b class="nc"><i>336</i>&nbsp;        actions.put(Actions.CUT, (BaseAction) this::cut);</b>
<i>337</i>&nbsp;
<i>338</i>&nbsp;        //when you modify this action be sure to adjust Actions.CUT,
<i>339</i>&nbsp;        //they are the same except of the Localization, delete confirmation and Actions.COPY call
<b class="nc"><i>340</i>&nbsp;        actions.put(Actions.DELETE, (BaseAction) () -&gt; delete(false));</b>
<i>341</i>&nbsp;
<i>342</i>&nbsp;        // The action for pasting entries or cell contents.
<i>343</i>&nbsp;        //  - more robust detection of available content flavors (doesn&#39;t only look at first one offered)
<i>344</i>&nbsp;        //  - support for parsing string-flavor clipboard contents which are bibtex entries.
<i>345</i>&nbsp;        //    This allows you to (a) paste entire bibtex entries from a text editor, web browser, etc
<i>346</i>&nbsp;        //                       (b) copy and paste entries between multiple instances of JabRef (since
<i>347</i>&nbsp;        //         only the text representation seems to get as far as the X clipboard, at least on my system)
<b class="nc"><i>348</i>&nbsp;        actions.put(Actions.PASTE, (BaseAction) () -&gt; paste());</b>
<i>349</i>&nbsp;
<b class="nc"><i>350</i>&nbsp;        actions.put(Actions.SELECT_ALL, (BaseAction) mainTable::selectAll);</b>
<i>351</i>&nbsp;
<i>352</i>&nbsp;        // The action for opening the preamble editor
<b class="nc"><i>353</i>&nbsp;        actions.put(Actions.EDIT_PREAMBLE, (BaseAction) () -&gt; {</b>
<b class="nc"><i>354</i>&nbsp;            if (preambleEditor == null) {</b>
<b class="nc"><i>355</i>&nbsp;                PreambleEditor form = new PreambleEditor(frame, BasePanel.this, bibDatabaseContext.getDatabase());</b>
<b class="nc"><i>356</i>&nbsp;                form.setLocationRelativeTo(frame);</b>
<b class="nc"><i>357</i>&nbsp;                form.setVisible(true);</b>
<b class="nc"><i>358</i>&nbsp;                preambleEditor = form;</b>
<b class="nc"><i>359</i>&nbsp;            } else {</b>
<b class="nc"><i>360</i>&nbsp;                preambleEditor.setVisible(true);</b>
<i>361</i>&nbsp;            }
<i>362</i>&nbsp;
<b class="nc"><i>363</i>&nbsp;        });</b>
<i>364</i>&nbsp;
<i>365</i>&nbsp;        // The action for opening the string editor
<b class="nc"><i>366</i>&nbsp;        actions.put(Actions.EDIT_STRINGS, (BaseAction) () -&gt; {</b>
<b class="nc"><i>367</i>&nbsp;            if (stringDialog == null) {</b>
<b class="nc"><i>368</i>&nbsp;                StringDialog form = new StringDialog(frame, BasePanel.this, bibDatabaseContext.getDatabase());</b>
<b class="nc"><i>369</i>&nbsp;                form.setVisible(true);</b>
<b class="nc"><i>370</i>&nbsp;                stringDialog = form;</b>
<b class="nc"><i>371</i>&nbsp;            } else {</b>
<b class="nc"><i>372</i>&nbsp;                stringDialog.setVisible(true);</b>
<i>373</i>&nbsp;            }
<i>374</i>&nbsp;
<b class="nc"><i>375</i>&nbsp;        });</b>
<i>376</i>&nbsp;
<b class="nc"><i>377</i>&nbsp;        actions.put(FindUnlinkedFilesDialog.ACTION_COMMAND, (BaseAction) () -&gt; {</b>
<b class="nc"><i>378</i>&nbsp;            final FindUnlinkedFilesDialog dialog = new FindUnlinkedFilesDialog(frame, frame, BasePanel.this);</b>
<b class="nc"><i>379</i>&nbsp;            dialog.setLocationRelativeTo(frame);</b>
<b class="nc"><i>380</i>&nbsp;            dialog.setVisible(true);</b>
<b class="nc"><i>381</i>&nbsp;        });</b>
<i>382</i>&nbsp;
<i>383</i>&nbsp;        // The action for auto-generating keys.
<b class="nc"><i>384</i>&nbsp;        actions.put(Actions.MAKE_KEY, new AbstractWorker() {</b>
<i>385</i>&nbsp;
<i>386</i>&nbsp;            List&lt;BibEntry&gt; entries;
<i>387</i>&nbsp;            int numSelected;
<i>388</i>&nbsp;            boolean canceled;
<i>389</i>&nbsp;
<i>390</i>&nbsp;
<i>391</i>&nbsp;            // Run first, in EDT:
<i>392</i>&nbsp;            @Override
<i>393</i>&nbsp;            public void init() {
<b class="nc"><i>394</i>&nbsp;                entries = getSelectedEntries();</b>
<b class="nc"><i>395</i>&nbsp;                numSelected = entries.size();</b>
<i>396</i>&nbsp;
<b class="nc"><i>397</i>&nbsp;                if (entries.isEmpty()) { // None selected. Inform the user to select entries first.</b>
<b class="nc"><i>398</i>&nbsp;                    JOptionPane.showMessageDialog(frame,</b>
<b class="nc"><i>399</i>&nbsp;                            Localization.lang(&quot;First select the entries you want keys to be generated for.&quot;),</b>
<b class="nc"><i>400</i>&nbsp;                            Localization.lang(&quot;Autogenerate BibTeX keys&quot;), JOptionPane.INFORMATION_MESSAGE);</b>
<b class="nc"><i>401</i>&nbsp;                    return;</b>
<i>402</i>&nbsp;                }
<b class="nc"><i>403</i>&nbsp;                frame.block();</b>
<b class="nc"><i>404</i>&nbsp;                output(formatOutputMessage(Localization.lang(&quot;Generating BibTeX key for&quot;), numSelected));</b>
<b class="nc"><i>405</i>&nbsp;            }</b>
<i>406</i>&nbsp;
<i>407</i>&nbsp;            // Run second, on a different thread:
<i>408</i>&nbsp;            @Override
<i>409</i>&nbsp;            public void run() {
<i>410</i>&nbsp;                // We don&#39;t want to generate keys for entries which already have one thus remove the entries
<b class="nc"><i>411</i>&nbsp;                if (Globals.prefs.getBoolean(JabRefPreferences.AVOID_OVERWRITING_KEY)) {</b>
<b class="nc"><i>412</i>&nbsp;                    entries.removeIf(BibEntry::hasCiteKey);</b>
<i>413</i>&nbsp;
<i>414</i>&nbsp;                // if we&#39;re going to override some cite keys warn the user about it
<b class="nc"><i>415</i>&nbsp;                } else if (Globals.prefs.getBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY)) {</b>
<b class="nc"><i>416</i>&nbsp;                    if (entries.parallelStream().anyMatch(BibEntry::hasCiteKey)) {</b>
<b class="nc"><i>417</i>&nbsp;                        CheckBoxMessage cbm = new CheckBoxMessage(</b>
<b class="nc"><i>418</i>&nbsp;                                Localization.lang(&quot;One or more keys will be overwritten. Continue?&quot;),</b>
<b class="nc"><i>419</i>&nbsp;                                Localization.lang(&quot;Disable this confirmation dialog&quot;), false);</b>
<b class="nc"><i>420</i>&nbsp;                        final int answer = JOptionPane.showConfirmDialog(frame, cbm,</b>
<b class="nc"><i>421</i>&nbsp;                                Localization.lang(&quot;Overwrite keys&quot;), JOptionPane.YES_NO_OPTION);</b>
<b class="nc"><i>422</i>&nbsp;                        Globals.prefs.putBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY, !cbm.isSelected());</b>
<i>423</i>&nbsp;
<i>424</i>&nbsp;                        // The user doesn&#39;t want to overide cite keys
<b class="nc"><i>425</i>&nbsp;                        if (answer == JOptionPane.NO_OPTION) {</b>
<b class="nc"><i>426</i>&nbsp;                            canceled = true;</b>
<b class="nc"><i>427</i>&nbsp;                            return;</b>
<i>428</i>&nbsp;                        }
<i>429</i>&nbsp;                    }
<i>430</i>&nbsp;                }
<i>431</i>&nbsp;
<i>432</i>&nbsp;                // generate the new cite keys for each entry
<b class="nc"><i>433</i>&nbsp;                final NamedCompound ce = new NamedCompound(Localization.lang(&quot;Autogenerate BibTeX keys&quot;));</b>
<b class="nc"><i>434</i>&nbsp;                AbstractBibtexKeyPattern citeKeyPattern = bibDatabaseContext.getMetaData()</b>
<b class="nc"><i>435</i>&nbsp;                        .getCiteKeyPattern(Globals.prefs.getBibtexKeyPatternPreferences().getKeyPattern());</b>
<b class="nc"><i>436</i>&nbsp;                for (BibEntry entry : entries) {</b>
<b class="nc"><i>437</i>&nbsp;                    String oldCiteKey = entry.getCiteKeyOptional().orElse(&quot;&quot;);</b>
<b class="nc"><i>438</i>&nbsp;                    BibtexKeyPatternUtil.makeAndSetLabel(citeKeyPattern, bibDatabaseContext.getDatabase(),</b>
<b class="nc"><i>439</i>&nbsp;                            entry, Globals.prefs.getBibtexKeyPatternPreferences());</b>
<b class="nc"><i>440</i>&nbsp;                    String newCiteKey = entry.getCiteKeyOptional().orElse(&quot;&quot;);</b>
<b class="nc"><i>441</i>&nbsp;                    if (!oldCiteKey.equals(newCiteKey)) {</b>
<b class="nc"><i>442</i>&nbsp;                        ce.addEdit(new UndoableKeyChange(entry, oldCiteKey, newCiteKey));</b>
<i>443</i>&nbsp;                    }
<b class="nc"><i>444</i>&nbsp;                }</b>
<b class="nc"><i>445</i>&nbsp;                ce.end();</b>
<i>446</i>&nbsp;
<i>447</i>&nbsp;                // register the undo event only if new cite keys were generated
<b class="nc"><i>448</i>&nbsp;                if (ce.hasEdits()) {</b>
<b class="nc"><i>449</i>&nbsp;                    getUndoManager().addEdit(ce);</b>
<i>450</i>&nbsp;                }
<b class="nc"><i>451</i>&nbsp;            }</b>
<i>452</i>&nbsp;
<i>453</i>&nbsp;            // Run third, on EDT:
<i>454</i>&nbsp;            @Override
<i>455</i>&nbsp;            public void update() {
<b class="nc"><i>456</i>&nbsp;                if (canceled) {</b>
<b class="nc"><i>457</i>&nbsp;                    frame.unblock();</b>
<b class="nc"><i>458</i>&nbsp;                    return;</b>
<i>459</i>&nbsp;                }
<b class="nc"><i>460</i>&nbsp;                markBaseChanged();</b>
<b class="nc"><i>461</i>&nbsp;                numSelected = entries.size();</b>
<i>462</i>&nbsp;
<i>463</i>&nbsp;                ////////////////////////////////////////////////////////////////////////////////
<i>464</i>&nbsp;                //          Prevent selection loss for autogenerated BibTeX-Keys
<i>465</i>&nbsp;                ////////////////////////////////////////////////////////////////////////////////
<b class="nc"><i>466</i>&nbsp;                for (final BibEntry bibEntry : entries) {</b>
<b class="nc"><i>467</i>&nbsp;                    SwingUtilities.invokeLater(() -&gt; {</b>
<b class="nc"><i>468</i>&nbsp;                        final int row = mainTable.findEntry(bibEntry);</b>
<b class="nc"><i>469</i>&nbsp;                        if ((row &gt;= 0) &amp;&amp; (mainTable.getSelectedRowCount() &lt; entries.size())) {</b>
<b class="nc"><i>470</i>&nbsp;                            mainTable.addRowSelectionInterval(row, row);</b>
<i>471</i>&nbsp;                        }
<b class="nc"><i>472</i>&nbsp;                    });</b>
<b class="nc"><i>473</i>&nbsp;                }</b>
<i>474</i>&nbsp;                ////////////////////////////////////////////////////////////////////////////////
<b class="nc"><i>475</i>&nbsp;                output(formatOutputMessage(Localization.lang(&quot;Generated BibTeX key for&quot;), numSelected));</b>
<b class="nc"><i>476</i>&nbsp;                frame.unblock();</b>
<b class="nc"><i>477</i>&nbsp;            }</b>
<i>478</i>&nbsp;        });
<i>479</i>&nbsp;
<i>480</i>&nbsp;        // The action for cleaning up entry.
<b class="nc"><i>481</i>&nbsp;        actions.put(Actions.CLEANUP, cleanUpAction);</b>
<i>482</i>&nbsp;
<b class="nc"><i>483</i>&nbsp;        actions.put(Actions.MERGE_ENTRIES, (BaseAction) () -&gt; new MergeEntriesDialog(BasePanel.this));</b>
<i>484</i>&nbsp;
<b class="nc"><i>485</i>&nbsp;        actions.put(Actions.SEARCH, (BaseAction) frame.getGlobalSearchBar()::focus);</b>
<b class="nc"><i>486</i>&nbsp;        actions.put(Actions.GLOBAL_SEARCH, (BaseAction) frame.getGlobalSearchBar()::performGlobalSearch);</b>
<i>487</i>&nbsp;
<i>488</i>&nbsp;        // The action for copying the selected entry&#39;s key.
<b class="nc"><i>489</i>&nbsp;        actions.put(Actions.COPY_KEY, (BaseAction) () -&gt; copyKey());</b>
<i>490</i>&nbsp;
<i>491</i>&nbsp;        // The action for copying a cite for the selected entry.
<b class="nc"><i>492</i>&nbsp;        actions.put(Actions.COPY_CITE_KEY, (BaseAction) () -&gt; copyCiteKey());</b>
<i>493</i>&nbsp;
<i>494</i>&nbsp;        // The action for copying the BibTeX key and the title for the first selected entry
<b class="nc"><i>495</i>&nbsp;        actions.put(Actions.COPY_KEY_AND_TITLE, (BaseAction) () -&gt; copyKeyAndTitle());</b>
<i>496</i>&nbsp;
<b class="nc"><i>497</i>&nbsp;        actions.put(Actions.COPY_CITATION_ASCII_DOC, (BaseAction) () -&gt; copyCitationToClipboard(CitationStyleOutputFormat.ASCII_DOC));</b>
<b class="nc"><i>498</i>&nbsp;        actions.put(Actions.COPY_CITATION_XSLFO, (BaseAction) () -&gt; copyCitationToClipboard(CitationStyleOutputFormat.XSL_FO));</b>
<b class="nc"><i>499</i>&nbsp;        actions.put(Actions.COPY_CITATION_HTML, (BaseAction) () -&gt; copyCitationToClipboard(CitationStyleOutputFormat.HTML));</b>
<b class="nc"><i>500</i>&nbsp;        actions.put(Actions.COPY_CITATION_RTF, (BaseAction) () -&gt; copyCitationToClipboard(CitationStyleOutputFormat.RTF));</b>
<b class="nc"><i>501</i>&nbsp;        actions.put(Actions.COPY_CITATION_TEXT, (BaseAction) () -&gt; copyCitationToClipboard(CitationStyleOutputFormat.TEXT));</b>
<i>502</i>&nbsp;
<i>503</i>&nbsp;        // The action for copying the BibTeX keys as hyperlinks to the urls of the selected entries
<b class="nc"><i>504</i>&nbsp;        actions.put(Actions.COPY_KEY_AND_LINK, new CopyBibTeXKeyAndLinkAction(mainTable));</b>
<i>505</i>&nbsp;
<b class="nc"><i>506</i>&nbsp;        actions.put(Actions.MERGE_DATABASE, new AppendDatabaseAction(frame, this));</b>
<i>507</i>&nbsp;
<b class="nc"><i>508</i>&nbsp;        actions.put(Actions.ADD_FILE_LINK, new AttachFileAction(this));</b>
<i>509</i>&nbsp;
<b class="nc"><i>510</i>&nbsp;        actions.put(Actions.OPEN_EXTERNAL_FILE, (BaseAction) () -&gt; openExternalFile());</b>
<i>511</i>&nbsp;
<b class="nc"><i>512</i>&nbsp;        actions.put(Actions.OPEN_FOLDER, (BaseAction) () -&gt; JabRefExecutorService.INSTANCE.execute(() -&gt; {</b>
<b class="nc"><i>513</i>&nbsp;            final List&lt;File&gt; files = FileUtil.getListOfLinkedFiles(mainTable.getSelectedEntries(),</b>
<b class="nc"><i>514</i>&nbsp;                    bibDatabaseContext.getFileDirectories(Globals.prefs.getFileDirectoryPreferences()));</b>
<b class="nc"><i>515</i>&nbsp;            for (final File f : files) {</b>
<i>516</i>&nbsp;                try {
<b class="nc"><i>517</i>&nbsp;                    JabRefDesktop.openFolderAndSelectFile(f.getAbsolutePath());</b>
<b class="nc"><i>518</i>&nbsp;                } catch (IOException e) {</b>
<b class="nc"><i>519</i>&nbsp;                    LOGGER.info(&quot;Could not open folder&quot;, e);</b>
<b class="nc"><i>520</i>&nbsp;                }</b>
<b class="nc"><i>521</i>&nbsp;            }</b>
<b class="nc"><i>522</i>&nbsp;        }));</b>
<i>523</i>&nbsp;
<b class="nc"><i>524</i>&nbsp;        actions.put(Actions.OPEN_CONSOLE, (BaseAction) () -&gt; JabRefDesktop</b>
<b class="nc"><i>525</i>&nbsp;                .openConsole(frame.getCurrentBasePanel().getBibDatabaseContext().getDatabaseFile().orElse(null)));</b>
<i>526</i>&nbsp;
<b class="nc"><i>527</i>&nbsp;        actions.put(Actions.PULL_CHANGES_FROM_SHARED_DATABASE, (BaseAction) () -&gt; {</b>
<b class="nc"><i>528</i>&nbsp;            DBMSSynchronizer dbmsSynchronizer = frame.getCurrentBasePanel().getBibDatabaseContext().getDBMSSynchronizer();</b>
<b class="nc"><i>529</i>&nbsp;            dbmsSynchronizer.pullChanges();</b>
<b class="nc"><i>530</i>&nbsp;        });</b>
<i>531</i>&nbsp;
<b class="nc"><i>532</i>&nbsp;        actions.put(Actions.OPEN_URL, new OpenURLAction());</b>
<i>533</i>&nbsp;
<b class="nc"><i>534</i>&nbsp;        actions.put(Actions.MERGE_WITH_FETCHED_ENTRY, new MergeWithFetchedEntryAction(this));</b>
<i>535</i>&nbsp;
<b class="nc"><i>536</i>&nbsp;        actions.put(Actions.REPLACE_ALL, (BaseAction) () -&gt; {</b>
<b class="nc"><i>537</i>&nbsp;            final ReplaceStringDialog rsd = new ReplaceStringDialog(frame);</b>
<b class="nc"><i>538</i>&nbsp;            rsd.setVisible(true);</b>
<b class="nc"><i>539</i>&nbsp;            if (!rsd.okPressed()) {</b>
<b class="nc"><i>540</i>&nbsp;                return;</b>
<i>541</i>&nbsp;            }
<b class="nc"><i>542</i>&nbsp;            int counter = 0;</b>
<b class="nc"><i>543</i>&nbsp;            final NamedCompound ce = new NamedCompound(Localization.lang(&quot;Replace string&quot;));</b>
<b class="nc"><i>544</i>&nbsp;            if (rsd.selOnly()) {</b>
<b class="nc"><i>545</i>&nbsp;                for (BibEntry be : mainTable.getSelectedEntries()) {</b>
<b class="nc"><i>546</i>&nbsp;                    counter += rsd.replace(be, ce);</b>
<b class="nc"><i>547</i>&nbsp;                }</b>
<i>548</i>&nbsp;            } else {
<b class="nc"><i>549</i>&nbsp;                for (BibEntry entry : bibDatabaseContext.getDatabase().getEntries()) {</b>
<b class="nc"><i>550</i>&nbsp;                    counter += rsd.replace(entry, ce);</b>
<b class="nc"><i>551</i>&nbsp;                }</b>
<i>552</i>&nbsp;            }
<i>553</i>&nbsp;
<b class="nc"><i>554</i>&nbsp;            output(Localization.lang(&quot;Replaced&quot;) + &#39; &#39; + counter + &#39; &#39;</b>
<b class="nc"><i>555</i>&nbsp;                    + (counter == 1 ? Localization.lang(&quot;occurrence&quot;) : Localization.lang(&quot;occurrences&quot;)) + &#39;.&#39;);</b>
<b class="nc"><i>556</i>&nbsp;            if (counter &gt; 0) {</b>
<b class="nc"><i>557</i>&nbsp;                ce.end();</b>
<b class="nc"><i>558</i>&nbsp;                getUndoManager().addEdit(ce);</b>
<b class="nc"><i>559</i>&nbsp;                markBaseChanged();</b>
<i>560</i>&nbsp;            }
<b class="nc"><i>561</i>&nbsp;        });</b>
<i>562</i>&nbsp;
<b class="nc"><i>563</i>&nbsp;        actions.put(Actions.DUPLI_CHECK,</b>
<b class="nc"><i>564</i>&nbsp;                (BaseAction) () -&gt; JabRefExecutorService.INSTANCE.execute(new DuplicateSearch(BasePanel.this)));</b>
<i>565</i>&nbsp;
<b class="nc"><i>566</i>&nbsp;        actions.put(Actions.PLAIN_TEXT_IMPORT, (BaseAction) () -&gt; {</b>
<i>567</i>&nbsp;            // get Type of new entry
<b class="nc"><i>568</i>&nbsp;            EntryTypeDialog etd = new EntryTypeDialog(frame);</b>
<b class="nc"><i>569</i>&nbsp;            etd.setLocationRelativeTo(BasePanel.this);</b>
<b class="nc"><i>570</i>&nbsp;            etd.setVisible(true);</b>
<b class="nc"><i>571</i>&nbsp;            EntryType tp = etd.getChoice();</b>
<b class="nc"><i>572</i>&nbsp;            if (tp == null) {</b>
<b class="nc"><i>573</i>&nbsp;                return;</b>
<i>574</i>&nbsp;            }
<i>575</i>&nbsp;
<b class="nc"><i>576</i>&nbsp;            BibEntry bibEntry = new BibEntry(tp.getName());</b>
<b class="nc"><i>577</i>&nbsp;            TextInputDialog tidialog = new TextInputDialog(frame, bibEntry);</b>
<b class="nc"><i>578</i>&nbsp;            tidialog.setLocationRelativeTo(BasePanel.this);</b>
<b class="nc"><i>579</i>&nbsp;            tidialog.setVisible(true);</b>
<i>580</i>&nbsp;
<b class="nc"><i>581</i>&nbsp;            if (tidialog.okPressed()) {</b>
<b class="nc"><i>582</i>&nbsp;                UpdateField.setAutomaticFields(Collections.singletonList(bibEntry), false, false,</b>
<b class="nc"><i>583</i>&nbsp;                        Globals.prefs.getUpdateFieldPreferences());</b>
<b class="nc"><i>584</i>&nbsp;                insertEntry(bibEntry);</b>
<i>585</i>&nbsp;            }
<b class="nc"><i>586</i>&nbsp;        });</b>
<i>587</i>&nbsp;
<b class="nc"><i>588</i>&nbsp;        actions.put(Actions.MARK_ENTRIES, new MarkEntriesAction(frame, 0));</b>
<i>589</i>&nbsp;
<b class="nc"><i>590</i>&nbsp;        actions.put(Actions.UNMARK_ENTRIES, (BaseAction) () -&gt; {</b>
<i>591</i>&nbsp;            try {
<b class="nc"><i>592</i>&nbsp;                List&lt;BibEntry&gt; bes = mainTable.getSelectedEntries();</b>
<b class="nc"><i>593</i>&nbsp;                if (bes.isEmpty()) {</b>
<b class="nc"><i>594</i>&nbsp;                    output(Localization.lang(&quot;This operation requires one or more entries to be selected.&quot;));</b>
<b class="nc"><i>595</i>&nbsp;                    return;</b>
<i>596</i>&nbsp;                }
<b class="nc"><i>597</i>&nbsp;                NamedCompound ce = new NamedCompound(Localization.lang(&quot;Unmark entries&quot;));</b>
<b class="nc"><i>598</i>&nbsp;                for (BibEntry be : bes) {</b>
<b class="nc"><i>599</i>&nbsp;                    EntryMarker.unmarkEntry(be, false, bibDatabaseContext.getDatabase(), ce);</b>
<b class="nc"><i>600</i>&nbsp;                }</b>
<b class="nc"><i>601</i>&nbsp;                ce.end();</b>
<b class="nc"><i>602</i>&nbsp;                getUndoManager().addEdit(ce);</b>
<b class="nc"><i>603</i>&nbsp;                markBaseChanged();</b>
<i>604</i>&nbsp;                String outputStr;
<b class="nc"><i>605</i>&nbsp;                if (bes.size() == 1) {</b>
<b class="nc"><i>606</i>&nbsp;                    outputStr = Localization.lang(&quot;Unmarked selected entry&quot;);</b>
<i>607</i>&nbsp;                } else {
<b class="nc"><i>608</i>&nbsp;                    outputStr = Localization.lang(&quot;Unmarked all %0 selected entries&quot;, Integer.toString(bes.size()));</b>
<i>609</i>&nbsp;                }
<b class="nc"><i>610</i>&nbsp;                output(outputStr);</b>
<b class="nc"><i>611</i>&nbsp;            } catch (Throwable ex) {</b>
<b class="nc"><i>612</i>&nbsp;                LOGGER.warn(&quot;Could not unmark&quot;, ex);</b>
<b class="nc"><i>613</i>&nbsp;            }</b>
<b class="nc"><i>614</i>&nbsp;        });</b>
<i>615</i>&nbsp;
<b class="nc"><i>616</i>&nbsp;        actions.put(Actions.UNMARK_ALL, (BaseAction) () -&gt; {</b>
<b class="nc"><i>617</i>&nbsp;            NamedCompound ce = new NamedCompound(Localization.lang(&quot;Unmark all&quot;));</b>
<i>618</i>&nbsp;
<b class="nc"><i>619</i>&nbsp;            for (BibEntry be : bibDatabaseContext.getDatabase().getEntries()) {</b>
<b class="nc"><i>620</i>&nbsp;                EntryMarker.unmarkEntry(be, false, bibDatabaseContext.getDatabase(), ce);</b>
<b class="nc"><i>621</i>&nbsp;            }</b>
<b class="nc"><i>622</i>&nbsp;            ce.end();</b>
<b class="nc"><i>623</i>&nbsp;            getUndoManager().addEdit(ce);</b>
<b class="nc"><i>624</i>&nbsp;            markBaseChanged();</b>
<b class="nc"><i>625</i>&nbsp;            output(Localization.lang(&quot;Unmarked all entries&quot;));</b>
<b class="nc"><i>626</i>&nbsp;        });</b>
<i>627</i>&nbsp;
<i>628</i>&nbsp;        // Note that we can&#39;t put the number of entries that have been reverted into the undoText as the concrete number cannot be injected
<b class="nc"><i>629</i>&nbsp;        actions.put(new SpecialFieldValueViewModel(SpecialField.RELEVANCE.getValues().get(0)).getActionName(),</b>
<b class="nc"><i>630</i>&nbsp;                new SpecialFieldViewModel(SpecialField.RELEVANCE).getSpecialFieldAction(</b>
<b class="nc"><i>631</i>&nbsp;                        SpecialField.RELEVANCE.getValues().get(0), frame));</b>
<b class="nc"><i>632</i>&nbsp;        actions.put(new SpecialFieldValueViewModel(SpecialField.QUALITY.getValues().get(0)).getActionName(),</b>
<b class="nc"><i>633</i>&nbsp;                new SpecialFieldViewModel(SpecialField.QUALITY).getSpecialFieldAction(SpecialField.QUALITY.getValues().get(0), frame));</b>
<b class="nc"><i>634</i>&nbsp;        actions.put(new SpecialFieldValueViewModel(SpecialField.PRINTED.getValues().get(0)).getActionName(),</b>
<b class="nc"><i>635</i>&nbsp;                new SpecialFieldViewModel(SpecialField.PRINTED).getSpecialFieldAction(</b>
<b class="nc"><i>636</i>&nbsp;                        SpecialField.PRINTED.getValues().get(0), frame));</b>
<i>637</i>&nbsp;
<b class="nc"><i>638</i>&nbsp;        for (SpecialFieldValue prio : SpecialField.PRIORITY.getValues()) {</b>
<b class="nc"><i>639</i>&nbsp;            actions.put(new SpecialFieldValueViewModel(prio).getActionName(), new SpecialFieldViewModel(SpecialField.PRIORITY).getSpecialFieldAction(prio, this.frame));</b>
<b class="nc"><i>640</i>&nbsp;        }</b>
<b class="nc"><i>641</i>&nbsp;        for (SpecialFieldValue rank : SpecialField.RANKING.getValues()) {</b>
<b class="nc"><i>642</i>&nbsp;            actions.put(new SpecialFieldValueViewModel(rank).getActionName(), new SpecialFieldViewModel(SpecialField.RANKING).getSpecialFieldAction(rank, this.frame));</b>
<b class="nc"><i>643</i>&nbsp;        }</b>
<b class="nc"><i>644</i>&nbsp;        for (SpecialFieldValue status : SpecialField.READ_STATUS.getValues()) {</b>
<b class="nc"><i>645</i>&nbsp;            actions.put(new SpecialFieldValueViewModel(status).getActionName(), new SpecialFieldViewModel(SpecialField.READ_STATUS).getSpecialFieldAction(status, this.frame));</b>
<b class="nc"><i>646</i>&nbsp;        }</b>
<i>647</i>&nbsp;
<b class="nc"><i>648</i>&nbsp;        actions.put(Actions.TOGGLE_PREVIEW, (BaseAction) () -&gt; {</b>
<b class="nc"><i>649</i>&nbsp;            PreviewPreferences previewPreferences = Globals.prefs.getPreviewPreferences();</b>
<b class="nc"><i>650</i>&nbsp;            boolean enabled = !previewPreferences.isPreviewPanelEnabled();</b>
<b class="nc"><i>651</i>&nbsp;            PreviewPreferences newPreviewPreferences = previewPreferences</b>
<b class="nc"><i>652</i>&nbsp;                    .getBuilder()</b>
<b class="nc"><i>653</i>&nbsp;                    .withPreviewPanelEnabled(enabled)</b>
<b class="nc"><i>654</i>&nbsp;                    .build();</b>
<b class="nc"><i>655</i>&nbsp;            Globals.prefs.storePreviewPreferences(newPreviewPreferences);</b>
<b class="nc"><i>656</i>&nbsp;            setPreviewActiveBasePanels(enabled);</b>
<b class="nc"><i>657</i>&nbsp;            frame.setPreviewToggle(enabled);</b>
<b class="nc"><i>658</i>&nbsp;        });</b>
<i>659</i>&nbsp;
<b class="nc"><i>660</i>&nbsp;        actions.put(Actions.TOGGLE_HIGHLIGHTS_GROUPS_MATCHING_ANY, (BaseAction) () -&gt; {</b>
<b class="nc"><i>661</i>&nbsp;            new HighlightMatchingGroupPreferences(Globals.prefs).setToAny();</b>
<i>662</i>&nbsp;            // ping the listener so it updates:
<b class="nc"><i>663</i>&nbsp;            groupsHighlightListener.listChanged(null);</b>
<b class="nc"><i>664</i>&nbsp;        });</b>
<i>665</i>&nbsp;
<b class="nc"><i>666</i>&nbsp;        actions.put(Actions.TOGGLE_HIGHLIGHTS_GROUPS_MATCHING_ALL, (BaseAction) () -&gt; {</b>
<b class="nc"><i>667</i>&nbsp;            new HighlightMatchingGroupPreferences(Globals.prefs).setToAll();</b>
<i>668</i>&nbsp;            // ping the listener so it updates:
<b class="nc"><i>669</i>&nbsp;            groupsHighlightListener.listChanged(null);</b>
<b class="nc"><i>670</i>&nbsp;        });</b>
<i>671</i>&nbsp;
<b class="nc"><i>672</i>&nbsp;        actions.put(Actions.TOGGLE_HIGHLIGHTS_GROUPS_MATCHING_DISABLE, (BaseAction) () -&gt; {</b>
<b class="nc"><i>673</i>&nbsp;            new HighlightMatchingGroupPreferences(Globals.prefs).setToDisabled();</b>
<i>674</i>&nbsp;            // ping the listener so it updates:
<b class="nc"><i>675</i>&nbsp;            groupsHighlightListener.listChanged(null);</b>
<b class="nc"><i>676</i>&nbsp;        });</b>
<i>677</i>&nbsp;
<b class="nc"><i>678</i>&nbsp;        actions.put(Actions.NEXT_PREVIEW_STYLE, (BaseAction) selectionListener::nextPreviewStyle);</b>
<b class="nc"><i>679</i>&nbsp;        actions.put(Actions.PREVIOUS_PREVIEW_STYLE, (BaseAction) selectionListener::previousPreviewStyle);</b>
<i>680</i>&nbsp;
<b class="nc"><i>681</i>&nbsp;        actions.put(Actions.MANAGE_SELECTORS, (BaseAction) () -&gt; {</b>
<b class="nc"><i>682</i>&nbsp;            ContentSelectorDialog csd = new ContentSelectorDialog(frame, frame, BasePanel.this, false, null);</b>
<b class="nc"><i>683</i>&nbsp;            csd.setLocationRelativeTo(frame);</b>
<b class="nc"><i>684</i>&nbsp;            csd.setVisible(true);</b>
<b class="nc"><i>685</i>&nbsp;        });</b>
<i>686</i>&nbsp;
<b class="nc"><i>687</i>&nbsp;        actions.put(Actions.EXPORT_TO_CLIPBOARD, new ExportToClipboardAction(frame));</b>
<b class="nc"><i>688</i>&nbsp;        actions.put(Actions.SEND_AS_EMAIL, new SendAsEMailAction(frame));</b>
<i>689</i>&nbsp;
<b class="nc"><i>690</i>&nbsp;        actions.put(Actions.WRITE_XMP, new WriteXMPAction(this));</b>
<i>691</i>&nbsp;
<b class="nc"><i>692</i>&nbsp;        actions.put(Actions.ABBREVIATE_ISO, new AbbreviateAction(this, true));</b>
<b class="nc"><i>693</i>&nbsp;        actions.put(Actions.ABBREVIATE_MEDLINE, new AbbreviateAction(this, false));</b>
<b class="nc"><i>694</i>&nbsp;        actions.put(Actions.UNABBREVIATE, new UnabbreviateAction(this));</b>
<b class="nc"><i>695</i>&nbsp;        actions.put(Actions.AUTO_SET_FILE, new SynchronizeFileField(this));</b>
<i>696</i>&nbsp;
<b class="nc"><i>697</i>&nbsp;        actions.put(Actions.BACK, (BaseAction) BasePanel.this::back);</b>
<b class="nc"><i>698</i>&nbsp;        actions.put(Actions.FORWARD, (BaseAction) BasePanel.this::forward);</b>
<i>699</i>&nbsp;
<b class="nc"><i>700</i>&nbsp;        actions.put(Actions.RESOLVE_DUPLICATE_KEYS, new SearchFixDuplicateLabels(this));</b>
<i>701</i>&nbsp;
<b class="nc"><i>702</i>&nbsp;        actions.put(Actions.ADD_TO_GROUP, new GroupAddRemoveDialog(this, true, false));</b>
<b class="nc"><i>703</i>&nbsp;        actions.put(Actions.REMOVE_FROM_GROUP, new GroupAddRemoveDialog(this, false, false));</b>
<b class="nc"><i>704</i>&nbsp;        actions.put(Actions.MOVE_TO_GROUP, new GroupAddRemoveDialog(this, true, true));</b>
<i>705</i>&nbsp;
<b class="nc"><i>706</i>&nbsp;        actions.put(Actions.DOWNLOAD_FULL_TEXT, new FindFullTextAction(this));</b>
<b class="nc"><i>707</i>&nbsp;    }</b>
<i>708</i>&nbsp;
<i>709</i>&nbsp;    /**
<i>710</i>&nbsp;     * Generates and copies citations based on the selected entries to the clipboard
<i>711</i>&nbsp;     * @param outputFormat the desired {@link CitationStyleOutputFormat}
<i>712</i>&nbsp;     */
<i>713</i>&nbsp;    private void copyCitationToClipboard(CitationStyleOutputFormat outputFormat) {
<b class="nc"><i>714</i>&nbsp;        new CitationStyleToClipboardWorker(this, outputFormat).execute();</b>
<b class="nc"><i>715</i>&nbsp;    }</b>
<i>716</i>&nbsp;
<i>717</i>&nbsp;    private void copy() {
<b class="nc"><i>718</i>&nbsp;        List&lt;BibEntry&gt; bes = mainTable.getSelectedEntries();</b>
<i>719</i>&nbsp;
<b class="nc"><i>720</i>&nbsp;        if (bes.isEmpty()) {</b>
<i>721</i>&nbsp;            // The user maybe selected a single cell.
<i>722</i>&nbsp;            // TODO: Check if this can actually happen
<b class="nc"><i>723</i>&nbsp;            int[] rows = mainTable.getSelectedRows();</b>
<b class="nc"><i>724</i>&nbsp;            int[] cols = mainTable.getSelectedColumns();</b>
<b class="nc"><i>725</i>&nbsp;            if ((cols.length == 1) &amp;&amp; (rows.length == 1)) {</b>
<i>726</i>&nbsp;                // Copy single value.
<b class="nc"><i>727</i>&nbsp;                Object o = mainTable.getValueAt(rows[0], cols[0]);</b>
<b class="nc"><i>728</i>&nbsp;                if (o != null) {</b>
<b class="nc"><i>729</i>&nbsp;                    StringSelection ss = new StringSelection(o.toString());</b>
<b class="nc"><i>730</i>&nbsp;                    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss, BasePanel.this);</b>
<i>731</i>&nbsp;
<b class="nc"><i>732</i>&nbsp;                    output(Localization.lang(&quot;Copied cell contents&quot;) + &#39;.&#39;);</b>
<i>733</i>&nbsp;                }
<i>734</i>&nbsp;            }
<b class="nc"><i>735</i>&nbsp;        } else {</b>
<b class="nc"><i>736</i>&nbsp;            TransferableBibtexEntry trbe = new TransferableBibtexEntry(bes);</b>
<i>737</i>&nbsp;            // ! look at ClipBoardManager
<b class="nc"><i>738</i>&nbsp;            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(trbe, BasePanel.this);</b>
<b class="nc"><i>739</i>&nbsp;            output(formatOutputMessage(Localization.lang(&quot;Copied&quot;), bes.size()));</b>
<i>740</i>&nbsp;        }
<b class="nc"><i>741</i>&nbsp;    }</b>
<i>742</i>&nbsp;
<i>743</i>&nbsp;    private void cut() {
<b class="nc"><i>744</i>&nbsp;        runCommand(Actions.COPY);</b>
<i>745</i>&nbsp;        // cannot call runCommand(Actions.DELETE), b/c it will call delete(false) with the wrong parameter
<b class="nc"><i>746</i>&nbsp;        delete(true);</b>
<b class="nc"><i>747</i>&nbsp;    }</b>
<i>748</i>&nbsp;
<i>749</i>&nbsp;    /**
<i>750</i>&nbsp;     * Removes the selected entries from the database
<i>751</i>&nbsp;     * @param cut If false the user will get asked if he really wants to delete the entries, and it will be localized
<i>752</i>&nbsp;     *            as &quot;deleted&quot;.
<i>753</i>&nbsp;     *            If true the action will be localized as &quot;cut&quot;
<i>754</i>&nbsp;     */
<i>755</i>&nbsp;    private void delete(boolean cut) {
<b class="nc"><i>756</i>&nbsp;        List&lt;BibEntry&gt; entries = mainTable.getSelectedEntries();</b>
<b class="nc"><i>757</i>&nbsp;        if (entries.isEmpty()) {</b>
<b class="nc"><i>758</i>&nbsp;            return;</b>
<i>759</i>&nbsp;        }
<b class="nc"><i>760</i>&nbsp;        if (!cut &amp;&amp; !showDeleteConfirmationDialog(entries.size())) {</b>
<b class="nc"><i>761</i>&nbsp;            return;</b>
<i>762</i>&nbsp;        }
<i>763</i>&nbsp;
<i>764</i>&nbsp;        // select the next entry to stay at the same place as before (or the previous if we&#39;re already at the end)
<b class="nc"><i>765</i>&nbsp;        if (mainTable.getSelectedRow() != (mainTable.getRowCount() -1)){</b>
<b class="nc"><i>766</i>&nbsp;            selectNextEntry();</b>
<i>767</i>&nbsp;        } else {
<b class="nc"><i>768</i>&nbsp;            selectPreviousEntry();</b>
<i>769</i>&nbsp;        }
<i>770</i>&nbsp;
<i>771</i>&nbsp;        NamedCompound compound;
<b class="nc"><i>772</i>&nbsp;        if (cut) {</b>
<b class="nc"><i>773</i>&nbsp;            compound = new NamedCompound(</b>
<b class="nc"><i>774</i>&nbsp;                    (entries.size() &gt; 1 ? Localization.lang(&quot;cut entries&quot;) : Localization.lang(&quot;cut entry&quot;)));</b>
<i>775</i>&nbsp;        } else {
<b class="nc"><i>776</i>&nbsp;            compound = new NamedCompound(</b>
<b class="nc"><i>777</i>&nbsp;                    (entries.size() &gt; 1 ? Localization.lang(&quot;delete entries&quot;) : Localization.lang(&quot;delete entry&quot;)));</b>
<i>778</i>&nbsp;        }
<b class="nc"><i>779</i>&nbsp;        for (BibEntry entry : entries) {</b>
<b class="nc"><i>780</i>&nbsp;            compound.addEdit(new UndoableRemoveEntry(bibDatabaseContext.getDatabase(), entry, BasePanel.this));</b>
<b class="nc"><i>781</i>&nbsp;            bibDatabaseContext.getDatabase().removeEntry(entry);</b>
<b class="nc"><i>782</i>&nbsp;            ensureNotShowingBottomPanel(entry);</b>
<b class="nc"><i>783</i>&nbsp;        }</b>
<b class="nc"><i>784</i>&nbsp;        compound.end();</b>
<b class="nc"><i>785</i>&nbsp;        getUndoManager().addEdit(compound);</b>
<i>786</i>&nbsp;
<b class="nc"><i>787</i>&nbsp;        markBaseChanged();</b>
<b class="nc"><i>788</i>&nbsp;        frame.output(formatOutputMessage(cut ? Localization.lang(&quot;Cut&quot;) : Localization.lang(&quot;Deleted&quot;), entries.size()));</b>
<i>789</i>&nbsp;
<i>790</i>&nbsp;        // prevent the main table from loosing focus
<b class="nc"><i>791</i>&nbsp;        mainTable.requestFocus();</b>
<b class="nc"><i>792</i>&nbsp;    }</b>
<i>793</i>&nbsp;
<i>794</i>&nbsp;    private void paste() {
<b class="nc"><i>795</i>&nbsp;        Collection&lt;BibEntry&gt; bes = new ClipBoardManager().extractBibEntriesFromClipboard();</b>
<i>796</i>&nbsp;
<i>797</i>&nbsp;        // finally we paste in the entries (if any), which either came from TransferableBibtexEntries
<i>798</i>&nbsp;        // or were parsed from a string
<b class="nc"><i>799</i>&nbsp;        if (!bes.isEmpty()) {</b>
<i>800</i>&nbsp;
<b class="nc"><i>801</i>&nbsp;            NamedCompound ce = new NamedCompound(</b>
<b class="nc"><i>802</i>&nbsp;                    (bes.size() &gt; 1 ? Localization.lang(&quot;paste entries&quot;) : Localization.lang(&quot;paste entry&quot;)));</b>
<i>803</i>&nbsp;
<i>804</i>&nbsp;            // Store the first inserted bibtexentry.
<i>805</i>&nbsp;            // bes[0] does not work as bes[0] is first clonded,
<i>806</i>&nbsp;            // then inserted.
<i>807</i>&nbsp;            // This entry is used to open up an entry editor
<i>808</i>&nbsp;            // for the first inserted entry.
<b class="nc"><i>809</i>&nbsp;            BibEntry firstBE = null;</b>
<i>810</i>&nbsp;
<b class="nc"><i>811</i>&nbsp;            for (BibEntry be1 : bes) {</b>
<i>812</i>&nbsp;
<b class="nc"><i>813</i>&nbsp;                BibEntry be = (BibEntry) be1.clone();</b>
<b class="nc"><i>814</i>&nbsp;                if (firstBE == null) {</b>
<b class="nc"><i>815</i>&nbsp;                    firstBE = be;</b>
<i>816</i>&nbsp;                }
<b class="nc"><i>817</i>&nbsp;                UpdateField.setAutomaticFields(be, Globals.prefs.getUpdateFieldPreferences());</b>
<i>818</i>&nbsp;
<i>819</i>&nbsp;                // We have to clone the
<i>820</i>&nbsp;                // entries, since the pasted
<i>821</i>&nbsp;                // entries must exist
<i>822</i>&nbsp;                // independently of the copied
<i>823</i>&nbsp;                // ones.
<b class="nc"><i>824</i>&nbsp;                bibDatabaseContext.getDatabase().insertEntry(be);</b>
<i>825</i>&nbsp;
<b class="nc"><i>826</i>&nbsp;                ce.addEdit(new UndoableInsertEntry(bibDatabaseContext.getDatabase(), be, BasePanel.this));</b>
<i>827</i>&nbsp;
<b class="nc"><i>828</i>&nbsp;            }</b>
<b class="nc"><i>829</i>&nbsp;            ce.end();</b>
<b class="nc"><i>830</i>&nbsp;            getUndoManager().addEdit(ce);</b>
<b class="nc"><i>831</i>&nbsp;            output(formatOutputMessage(Localization.lang(&quot;Pasted&quot;), bes.size()));</b>
<b class="nc"><i>832</i>&nbsp;            markBaseChanged();</b>
<i>833</i>&nbsp;
<b class="nc"><i>834</i>&nbsp;            highlightEntry(firstBE);</b>
<b class="nc"><i>835</i>&nbsp;            mainTable.requestFocus();</b>
<i>836</i>&nbsp;
<b class="nc"><i>837</i>&nbsp;            if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_OPEN_FORM)) {</b>
<b class="nc"><i>838</i>&nbsp;                selectionListener.editSignalled(firstBE);</b>
<i>839</i>&nbsp;            }
<i>840</i>&nbsp;        }
<b class="nc"><i>841</i>&nbsp;    }</b>
<i>842</i>&nbsp;
<i>843</i>&nbsp;    private void copyCiteKey() {
<b class="nc"><i>844</i>&nbsp;        List&lt;BibEntry&gt; bes = mainTable.getSelectedEntries();</b>
<b class="nc"><i>845</i>&nbsp;        if (!bes.isEmpty()) {</b>
<b class="nc"><i>846</i>&nbsp;            storeCurrentEdit();</b>
<b class="nc"><i>847</i>&nbsp;            List&lt;String&gt; keys = new ArrayList&lt;&gt;(bes.size());</b>
<i>848</i>&nbsp;            // Collect all non-null keys.
<b class="nc"><i>849</i>&nbsp;            for (BibEntry be : bes) {</b>
<b class="nc"><i>850</i>&nbsp;                be.getCiteKeyOptional().ifPresent(keys::add);</b>
<b class="nc"><i>851</i>&nbsp;            }</b>
<b class="nc"><i>852</i>&nbsp;            if (keys.isEmpty()) {</b>
<b class="nc"><i>853</i>&nbsp;                output(Localization.lang(&quot;None of the selected entries have BibTeX keys.&quot;));</b>
<b class="nc"><i>854</i>&nbsp;                return;</b>
<i>855</i>&nbsp;            }
<i>856</i>&nbsp;
<b class="nc"><i>857</i>&nbsp;            String sb = String.join(&quot;,&quot;, keys);</b>
<b class="nc"><i>858</i>&nbsp;            StringSelection ss = new StringSelection(&quot;\\cite{&quot; + sb + &#39;}&#39;);</b>
<b class="nc"><i>859</i>&nbsp;            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss, BasePanel.this);</b>
<i>860</i>&nbsp;
<b class="nc"><i>861</i>&nbsp;            if (keys.size() == bes.size()) {</b>
<i>862</i>&nbsp;                // All entries had keys.
<b class="nc"><i>863</i>&nbsp;                output(bes.size() &gt; 1 ? Localization.lang(&quot;Copied keys&quot;) : Localization.lang(&quot;Copied key&quot;) + &#39;.&#39;);</b>
<i>864</i>&nbsp;            } else {
<b class="nc"><i>865</i>&nbsp;                output(Localization.lang(&quot;Warning: %0 out of %1 entries have undefined BibTeX key.&quot;,</b>
<b class="nc"><i>866</i>&nbsp;                        Integer.toString(bes.size() - keys.size()), Integer.toString(bes.size())));</b>
<i>867</i>&nbsp;            }
<i>868</i>&nbsp;        }
<b class="nc"><i>869</i>&nbsp;    }</b>
<i>870</i>&nbsp;
<i>871</i>&nbsp;    private void copyKey() {
<b class="nc"><i>872</i>&nbsp;        List&lt;BibEntry&gt; bes = mainTable.getSelectedEntries();</b>
<b class="nc"><i>873</i>&nbsp;        if (!bes.isEmpty()) {</b>
<b class="nc"><i>874</i>&nbsp;            storeCurrentEdit();</b>
<b class="nc"><i>875</i>&nbsp;            List&lt;String&gt; keys = new ArrayList&lt;&gt;(bes.size());</b>
<i>876</i>&nbsp;            // Collect all non-null keys.
<b class="nc"><i>877</i>&nbsp;            for (BibEntry be : bes) {</b>
<b class="nc"><i>878</i>&nbsp;                be.getCiteKeyOptional().ifPresent(keys::add);</b>
<b class="nc"><i>879</i>&nbsp;            }</b>
<b class="nc"><i>880</i>&nbsp;            if (keys.isEmpty()) {</b>
<b class="nc"><i>881</i>&nbsp;                output(Localization.lang(&quot;None of the selected entries have BibTeX keys.&quot;));</b>
<b class="nc"><i>882</i>&nbsp;                return;</b>
<i>883</i>&nbsp;            }
<i>884</i>&nbsp;
<b class="nc"><i>885</i>&nbsp;            StringSelection ss = new StringSelection(String.join(&quot;,&quot;, keys));</b>
<b class="nc"><i>886</i>&nbsp;            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss, BasePanel.this);</b>
<i>887</i>&nbsp;
<b class="nc"><i>888</i>&nbsp;            if (keys.size() == bes.size()) {</b>
<i>889</i>&nbsp;                // All entries had keys.
<b class="nc"><i>890</i>&nbsp;                output((bes.size() &gt; 1 ? Localization.lang(&quot;Copied keys&quot;) : Localization.lang(&quot;Copied key&quot;)) + &#39;.&#39;);</b>
<i>891</i>&nbsp;            } else {
<b class="nc"><i>892</i>&nbsp;                output(Localization.lang(&quot;Warning: %0 out of %1 entries have undefined BibTeX key.&quot;,</b>
<b class="nc"><i>893</i>&nbsp;                        Integer.toString(bes.size() - keys.size()), Integer.toString(bes.size())));</b>
<i>894</i>&nbsp;            }
<i>895</i>&nbsp;        }
<b class="nc"><i>896</i>&nbsp;    }</b>
<i>897</i>&nbsp;
<i>898</i>&nbsp;    private void copyKeyAndTitle() {
<b class="nc"><i>899</i>&nbsp;        List&lt;BibEntry&gt; bes = mainTable.getSelectedEntries();</b>
<b class="nc"><i>900</i>&nbsp;        if (!bes.isEmpty()) {</b>
<b class="nc"><i>901</i>&nbsp;            storeCurrentEdit();</b>
<i>902</i>&nbsp;
<i>903</i>&nbsp;            // OK: in a future version, this string should be configurable to allow arbitrary exports
<b class="nc"><i>904</i>&nbsp;            StringReader sr = new StringReader(</b>
<i>905</i>&nbsp;                    &quot;\\bibtexkey - \\begin{title}\\format[RemoveBrackets]{\\title}\\end{title}\n&quot;);
<i>906</i>&nbsp;            Layout layout;
<i>907</i>&nbsp;            try {
<b class="nc"><i>908</i>&nbsp;                layout = new LayoutHelper(sr,</b>
<b class="nc"><i>909</i>&nbsp;                        Globals.prefs.getLayoutFormatterPreferences(Globals.journalAbbreviationLoader))</b>
<b class="nc"><i>910</i>&nbsp;                                .getLayoutFromText();</b>
<b class="nc"><i>911</i>&nbsp;            } catch (IOException e) {</b>
<b class="nc"><i>912</i>&nbsp;                LOGGER.info(&quot;Could not get layout&quot;, e);</b>
<b class="nc"><i>913</i>&nbsp;                return;</b>
<b class="nc"><i>914</i>&nbsp;            }</b>
<i>915</i>&nbsp;
<b class="nc"><i>916</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<i>917</i>&nbsp;
<b class="nc"><i>918</i>&nbsp;            int copied = 0;</b>
<i>919</i>&nbsp;            // Collect all non-null keys.
<b class="nc"><i>920</i>&nbsp;            for (BibEntry be : bes) {</b>
<b class="nc"><i>921</i>&nbsp;                if (be.hasCiteKey()) {</b>
<b class="nc"><i>922</i>&nbsp;                    copied++;</b>
<b class="nc"><i>923</i>&nbsp;                    sb.append(layout.doLayout(be, bibDatabaseContext.getDatabase()));</b>
<i>924</i>&nbsp;                }
<b class="nc"><i>925</i>&nbsp;            }</b>
<i>926</i>&nbsp;
<b class="nc"><i>927</i>&nbsp;            if (copied == 0) {</b>
<b class="nc"><i>928</i>&nbsp;                output(Localization.lang(&quot;None of the selected entries have BibTeX keys.&quot;));</b>
<b class="nc"><i>929</i>&nbsp;                return;</b>
<i>930</i>&nbsp;            }
<i>931</i>&nbsp;
<b class="nc"><i>932</i>&nbsp;            final StringSelection ss = new StringSelection(sb.toString());</b>
<b class="nc"><i>933</i>&nbsp;            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss, BasePanel.this);</b>
<i>934</i>&nbsp;
<b class="nc"><i>935</i>&nbsp;            if (copied == bes.size()) {</b>
<i>936</i>&nbsp;                // All entries had keys.
<b class="nc"><i>937</i>&nbsp;                output((bes.size() &gt; 1 ? Localization.lang(&quot;Copied keys&quot;) : Localization.lang(&quot;Copied key&quot;)) + &#39;.&#39;);</b>
<i>938</i>&nbsp;            } else {
<b class="nc"><i>939</i>&nbsp;                output(Localization.lang(&quot;Warning: %0 out of %1 entries have undefined BibTeX key.&quot;,</b>
<b class="nc"><i>940</i>&nbsp;                        Integer.toString(bes.size() - copied), Integer.toString(bes.size())));</b>
<i>941</i>&nbsp;            }
<i>942</i>&nbsp;        }
<b class="nc"><i>943</i>&nbsp;    }</b>
<i>944</i>&nbsp;
<i>945</i>&nbsp;    private void openExternalFile() {
<b class="nc"><i>946</i>&nbsp;        JabRefExecutorService.INSTANCE.execute(() -&gt; {</b>
<b class="nc"><i>947</i>&nbsp;            final List&lt;BibEntry&gt; bes = mainTable.getSelectedEntries();</b>
<b class="nc"><i>948</i>&nbsp;            if (bes.size() != 1) {</b>
<b class="nc"><i>949</i>&nbsp;                output(Localization.lang(&quot;This operation requires exactly one item to be selected.&quot;));</b>
<b class="nc"><i>950</i>&nbsp;                return;</b>
<i>951</i>&nbsp;            }
<i>952</i>&nbsp;
<b class="nc"><i>953</i>&nbsp;            final BibEntry entry = bes.get(0);</b>
<b class="nc"><i>954</i>&nbsp;            if (!entry.hasField(FieldName.FILE)) {</b>
<i>955</i>&nbsp;                // no bibtex field
<b class="nc"><i>956</i>&nbsp;                new SearchAndOpenFile(entry, BasePanel.this).searchAndOpen();</b>
<b class="nc"><i>957</i>&nbsp;                return;</b>
<i>958</i>&nbsp;            }
<b class="nc"><i>959</i>&nbsp;            FileListTableModel fileListTableModel = new FileListTableModel();</b>
<b class="nc"><i>960</i>&nbsp;            entry.getField(FieldName.FILE).ifPresent(fileListTableModel::setContent);</b>
<b class="nc"><i>961</i>&nbsp;            if (fileListTableModel.getRowCount() == 0) {</b>
<i>962</i>&nbsp;                // content in BibTeX field is not readable
<b class="nc"><i>963</i>&nbsp;                new SearchAndOpenFile(entry, BasePanel.this).searchAndOpen();</b>
<b class="nc"><i>964</i>&nbsp;                return;</b>
<i>965</i>&nbsp;            }
<b class="nc"><i>966</i>&nbsp;            FileListEntry flEntry = fileListTableModel.getEntry(0);</b>
<b class="nc"><i>967</i>&nbsp;            ExternalFileMenuItem item = new ExternalFileMenuItem(frame(), entry, &quot;&quot;, flEntry.link,</b>
<b class="nc"><i>968</i>&nbsp;                    flEntry.type.get().getIcon(), bibDatabaseContext, flEntry.type);</b>
<b class="nc"><i>969</i>&nbsp;            item.openLink();</b>
<b class="nc"><i>970</i>&nbsp;        });</b>
<b class="nc"><i>971</i>&nbsp;    }</b>
<i>972</i>&nbsp;
<i>973</i>&nbsp;    /**
<i>974</i>&nbsp;     * This method is called from JabRefFrame if a database specific action is requested by the user. Runs the command
<i>975</i>&nbsp;     * if it is defined, or prints an error message to the standard error stream.
<i>976</i>&nbsp;     *
<i>977</i>&nbsp;     * @param _command The name of the command to run.
<i>978</i>&nbsp;     */
<i>979</i>&nbsp;    public void runCommand(final String _command) {
<b class="nc"><i>980</i>&nbsp;        if (!actions.containsKey(_command)) {</b>
<b class="nc"><i>981</i>&nbsp;            LOGGER.info(&quot;No action defined for &#39;&quot; + _command + &#39;\&#39;&#39;);</b>
<b class="nc"><i>982</i>&nbsp;            return;</b>
<i>983</i>&nbsp;        }
<i>984</i>&nbsp;
<b class="nc"><i>985</i>&nbsp;        Object o = actions.get(_command);</b>
<i>986</i>&nbsp;        try {
<b class="nc"><i>987</i>&nbsp;            if (o instanceof BaseAction) {</b>
<b class="nc"><i>988</i>&nbsp;                ((BaseAction) o).action();</b>
<i>989</i>&nbsp;            } else {
<i>990</i>&nbsp;                // This part uses Spin&#39;s features:
<b class="nc"><i>991</i>&nbsp;                Runnable wrk = ((AbstractWorker) o).getWorker();</b>
<i>992</i>&nbsp;                // The Worker returned by getWorker() has been wrapped
<i>993</i>&nbsp;                // by Spin.off(), which makes its methods be run in
<i>994</i>&nbsp;                // a different thread from the EDT.
<b class="nc"><i>995</i>&nbsp;                CallBack clb = ((AbstractWorker) o).getCallBack();</b>
<i>996</i>&nbsp;
<b class="nc"><i>997</i>&nbsp;                ((AbstractWorker) o).init(); // This method runs in this same thread, the EDT.</b>
<i>998</i>&nbsp;                // Useful for initial GUI actions, like printing a message.
<i>999</i>&nbsp;
<i>1000</i>&nbsp;                // The CallBack returned by getCallBack() has been wrapped
<i>1001</i>&nbsp;                // by Spin.over(), which makes its methods be run on
<i>1002</i>&nbsp;                // the EDT.
<b class="nc"><i>1003</i>&nbsp;                wrk.run(); // Runs the potentially time-consuming action</b>
<i>1004</i>&nbsp;                // without freezing the GUI. The magic is that THIS line
<i>1005</i>&nbsp;                // of execution will not continue until run() is finished.
<b class="nc"><i>1006</i>&nbsp;                clb.update(); // Runs the update() method on the EDT.</b>
<i>1007</i>&nbsp;            }
<b class="nc"><i>1008</i>&nbsp;        } catch (Throwable ex) {</b>
<i>1009</i>&nbsp;            // If the action has blocked the JabRefFrame before crashing, we need to unblock it.
<i>1010</i>&nbsp;            // The call to unblock will simply hide the glasspane, so there is no harm in calling
<i>1011</i>&nbsp;            // it even if the frame hasn&#39;t been blocked.
<b class="nc"><i>1012</i>&nbsp;            frame.unblock();</b>
<b class="nc"><i>1013</i>&nbsp;            LOGGER.error(&quot;runCommand error: &quot; + ex.getMessage(), ex);</b>
<b class="nc"><i>1014</i>&nbsp;        }</b>
<b class="nc"><i>1015</i>&nbsp;    }</b>
<i>1016</i>&nbsp;
<i>1017</i>&nbsp;    private boolean saveDatabase(File file, boolean selectedOnly, Charset enc,
<i>1018</i>&nbsp;            SavePreferences.DatabaseSaveType saveType) throws SaveException {
<i>1019</i>&nbsp;        SaveSession session;
<b class="nc"><i>1020</i>&nbsp;        frame.block();</b>
<b class="nc"><i>1021</i>&nbsp;        final String SAVE_DATABASE = Localization.lang(&quot;Save database&quot;);</b>
<i>1022</i>&nbsp;        try {
<b class="nc"><i>1023</i>&nbsp;            SavePreferences prefs = SavePreferences.loadForSaveFromPreferences(Globals.prefs).withEncoding(enc)</b>
<b class="nc"><i>1024</i>&nbsp;                    .withSaveType(saveType);</b>
<b class="nc"><i>1025</i>&nbsp;            BibtexDatabaseWriter&lt;SaveSession&gt; databaseWriter = new BibtexDatabaseWriter&lt;&gt;(</b>
<i>1026</i>&nbsp;                    FileSaveSession::new);
<b class="nc"><i>1027</i>&nbsp;            if (selectedOnly) {</b>
<b class="nc"><i>1028</i>&nbsp;                session = databaseWriter.savePartOfDatabase(bibDatabaseContext, mainTable.getSelectedEntries(), prefs);</b>
<i>1029</i>&nbsp;            } else {
<b class="nc"><i>1030</i>&nbsp;                session = databaseWriter.saveDatabase(bibDatabaseContext, prefs);</b>
<i>1031</i>&nbsp;            }
<i>1032</i>&nbsp;
<b class="nc"><i>1033</i>&nbsp;            registerUndoableChanges(session);</b>
<i>1034</i>&nbsp;        }
<i>1035</i>&nbsp;        // FIXME: not sure if this is really thrown anywhere
<b class="nc"><i>1036</i>&nbsp;        catch (UnsupportedCharsetException ex) {</b>
<b class="nc"><i>1037</i>&nbsp;            JOptionPane.showMessageDialog(frame,</b>
<b class="nc"><i>1038</i>&nbsp;                    Localization.lang(&quot;Could not save file.&quot;) + &#39; &#39;</b>
<b class="nc"><i>1039</i>&nbsp;                            + Localization.lang(&quot;Character encoding &#39;%0&#39; is not supported.&quot;, enc.displayName()),</b>
<i>1040</i>&nbsp;                    SAVE_DATABASE, JOptionPane.ERROR_MESSAGE);
<b class="nc"><i>1041</i>&nbsp;            throw new SaveException(&quot;rt&quot;);</b>
<b class="nc"><i>1042</i>&nbsp;        } catch (SaveException ex) {</b>
<b class="nc"><i>1043</i>&nbsp;            if (ex.specificEntry()) {</b>
<i>1044</i>&nbsp;                // Error occurred during processing of the entry. Highlight it:
<b class="nc"><i>1045</i>&nbsp;                highlightEntry(ex.getEntry());</b>
<b class="nc"><i>1046</i>&nbsp;                showEntry(ex.getEntry());</b>
<i>1047</i>&nbsp;            } else {
<b class="nc"><i>1048</i>&nbsp;                LOGGER.warn(&quot;Could not save&quot;, ex);</b>
<i>1049</i>&nbsp;            }
<i>1050</i>&nbsp;
<b class="nc"><i>1051</i>&nbsp;            JOptionPane.showMessageDialog(frame, Localization.lang(&quot;Could not save file.&quot;) + &quot;\n&quot; + ex.getMessage(),</b>
<i>1052</i>&nbsp;                    SAVE_DATABASE, JOptionPane.ERROR_MESSAGE);
<b class="nc"><i>1053</i>&nbsp;            throw new SaveException(&quot;rt&quot;);</b>
<i>1054</i>&nbsp;
<i>1055</i>&nbsp;        } finally {
<b class="nc"><i>1056</i>&nbsp;            frame.unblock();</b>
<b class="nc"><i>1057</i>&nbsp;        }</b>
<i>1058</i>&nbsp;
<b class="nc"><i>1059</i>&nbsp;        boolean commit = true;</b>
<b class="nc"><i>1060</i>&nbsp;        if (!session.getWriter().couldEncodeAll()) {</b>
<b class="nc"><i>1061</i>&nbsp;            FormBuilder builder = FormBuilder.create()</b>
<b class="nc"><i>1062</i>&nbsp;                    .layout(new FormLayout(&quot;left:pref, 4dlu, fill:pref&quot;, &quot;pref, 4dlu, pref&quot;));</b>
<b class="nc"><i>1063</i>&nbsp;            JTextArea ta = new JTextArea(session.getWriter().getProblemCharacters());</b>
<b class="nc"><i>1064</i>&nbsp;            ta.setEditable(false);</b>
<b class="nc"><i>1065</i>&nbsp;            builder.add(Localization.lang(&quot;The chosen encoding &#39;%0&#39; could not encode the following characters:&quot;,</b>
<b class="nc"><i>1066</i>&nbsp;                    session.getEncoding().displayName())).xy(1, 1);</b>
<b class="nc"><i>1067</i>&nbsp;            builder.add(ta).xy(3, 1);</b>
<b class="nc"><i>1068</i>&nbsp;            builder.add(Localization.lang(&quot;What do you want to do?&quot;)).xy(1, 3);</b>
<b class="nc"><i>1069</i>&nbsp;            String tryDiff = Localization.lang(&quot;Try different encoding&quot;);</b>
<b class="nc"><i>1070</i>&nbsp;            int answer = JOptionPane.showOptionDialog(frame, builder.getPanel(), SAVE_DATABASE,</b>
<i>1071</i>&nbsp;                    JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE, null,
<b class="nc"><i>1072</i>&nbsp;                    new String[] {Localization.lang(&quot;Save&quot;), tryDiff, Localization.lang(&quot;Cancel&quot;)}, tryDiff);</b>
<i>1073</i>&nbsp;
<b class="nc"><i>1074</i>&nbsp;            if (answer == JOptionPane.NO_OPTION) {</b>
<i>1075</i>&nbsp;                // The user wants to use another encoding.
<b class="nc"><i>1076</i>&nbsp;                Object choice = JOptionPane.showInputDialog(frame, Localization.lang(&quot;Select encoding&quot;), SAVE_DATABASE,</b>
<i>1077</i>&nbsp;                        JOptionPane.QUESTION_MESSAGE, null, Encodings.ENCODINGS_DISPLAYNAMES, enc);
<b class="nc"><i>1078</i>&nbsp;                if (choice == null) {</b>
<b class="nc"><i>1079</i>&nbsp;                    commit = false;</b>
<i>1080</i>&nbsp;                } else {
<b class="nc"><i>1081</i>&nbsp;                    Charset newEncoding = Charset.forName((String) choice);</b>
<b class="nc"><i>1082</i>&nbsp;                    return saveDatabase(file, selectedOnly, newEncoding, saveType);</b>
<i>1083</i>&nbsp;
<i>1084</i>&nbsp;                }
<b class="nc"><i>1085</i>&nbsp;            } else if (answer == JOptionPane.CANCEL_OPTION) {</b>
<b class="nc"><i>1086</i>&nbsp;                commit = false;</b>
<i>1087</i>&nbsp;            }
<i>1088</i>&nbsp;
<i>1089</i>&nbsp;        }
<i>1090</i>&nbsp;
<b class="nc"><i>1091</i>&nbsp;        if (commit) {</b>
<b class="nc"><i>1092</i>&nbsp;            session.commit(file.toPath());</b>
<b class="nc"><i>1093</i>&nbsp;            this.bibDatabaseContext.getMetaData().setEncoding(enc); // Make sure to remember which encoding we used.</b>
<i>1094</i>&nbsp;        } else {
<b class="nc"><i>1095</i>&nbsp;            session.cancel();</b>
<i>1096</i>&nbsp;        }
<i>1097</i>&nbsp;
<b class="nc"><i>1098</i>&nbsp;        return commit;</b>
<i>1099</i>&nbsp;    }
<i>1100</i>&nbsp;
<i>1101</i>&nbsp;    public void registerUndoableChanges(SaveSession session) {
<b class="nc"><i>1102</i>&nbsp;        NamedCompound ce = new NamedCompound(Localization.lang(&quot;Save actions&quot;));</b>
<b class="nc"><i>1103</i>&nbsp;        for (FieldChange change : session.getFieldChanges()) {</b>
<b class="nc"><i>1104</i>&nbsp;            ce.addEdit(new UndoableFieldChange(change));</b>
<b class="nc"><i>1105</i>&nbsp;        }</b>
<b class="nc"><i>1106</i>&nbsp;        ce.end();</b>
<b class="nc"><i>1107</i>&nbsp;        if (ce.hasEdits()) {</b>
<b class="nc"><i>1108</i>&nbsp;            getUndoManager().addEdit(ce);</b>
<i>1109</i>&nbsp;        }
<b class="nc"><i>1110</i>&nbsp;    }</b>
<i>1111</i>&nbsp;
<i>1112</i>&nbsp;    /**
<i>1113</i>&nbsp;     * This method is called from JabRefFrame when the user wants to create a new entry. If the argument is null, the
<i>1114</i>&nbsp;     * user is prompted for an entry type.
<i>1115</i>&nbsp;     *
<i>1116</i>&nbsp;     * @param type The type of the entry to create.
<i>1117</i>&nbsp;     * @return The newly created BibEntry or null the operation was canceled by the user.
<i>1118</i>&nbsp;     */
<i>1119</i>&nbsp;    public BibEntry newEntry(EntryType type) {
<b class="nc"><i>1120</i>&nbsp;        EntryType actualType = type;</b>
<b class="nc"><i>1121</i>&nbsp;        if (actualType == null) {</b>
<i>1122</i>&nbsp;            // Find out what type is wanted.
<b class="nc"><i>1123</i>&nbsp;            final EntryTypeDialog etd = new EntryTypeDialog(frame);</b>
<i>1124</i>&nbsp;            // We want to center the dialog, to make it look nicer.
<b class="nc"><i>1125</i>&nbsp;            etd.setLocationRelativeTo(frame);</b>
<b class="nc"><i>1126</i>&nbsp;            etd.setVisible(true);</b>
<b class="nc"><i>1127</i>&nbsp;            actualType = etd.getChoice();</b>
<i>1128</i>&nbsp;        }
<b class="nc"><i>1129</i>&nbsp;        if (actualType != null) { // Only if the dialog was not canceled.</b>
<b class="nc"><i>1130</i>&nbsp;            final BibEntry be = new BibEntry(actualType.getName());</b>
<i>1131</i>&nbsp;            try {
<b class="nc"><i>1132</i>&nbsp;                bibDatabaseContext.getDatabase().insertEntry(be);</b>
<i>1133</i>&nbsp;                // Set owner/timestamp if options are enabled:
<b class="nc"><i>1134</i>&nbsp;                List&lt;BibEntry&gt; list = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1135</i>&nbsp;                list.add(be);</b>
<b class="nc"><i>1136</i>&nbsp;                UpdateField.setAutomaticFields(list, true, true, Globals.prefs.getUpdateFieldPreferences());</b>
<i>1137</i>&nbsp;
<i>1138</i>&nbsp;                // Create an UndoableInsertEntry object.
<b class="nc"><i>1139</i>&nbsp;                getUndoManager().addEdit(new UndoableInsertEntry(bibDatabaseContext.getDatabase(), be, BasePanel.this));</b>
<b class="nc"><i>1140</i>&nbsp;                output(Localization.lang(&quot;Added new &#39;%0&#39; entry.&quot;, actualType.getName().toLowerCase()));</b>
<i>1141</i>&nbsp;
<i>1142</i>&nbsp;                // We are going to select the new entry. Before that, make sure that we are in
<i>1143</i>&nbsp;                // show-entry mode. If we aren&#39;t already in that mode, enter the WILL_SHOW_EDITOR
<i>1144</i>&nbsp;                // mode which makes sure the selection will trigger display of the entry editor
<i>1145</i>&nbsp;                // and adjustment of the splitter.
<b class="nc"><i>1146</i>&nbsp;                if (mode != BasePanelMode.SHOWING_EDITOR) {</b>
<b class="nc"><i>1147</i>&nbsp;                    mode = BasePanelMode.WILL_SHOW_EDITOR;</b>
<i>1148</i>&nbsp;                }
<i>1149</i>&nbsp;
<b class="nc"><i>1150</i>&nbsp;                highlightEntry(be);</b>
<i>1151</i>&nbsp;
<i>1152</i>&nbsp;                // The database just changed.
<b class="nc"><i>1153</i>&nbsp;                markBaseChanged();</b>
<i>1154</i>&nbsp;
<b class="nc"><i>1155</i>&nbsp;                final EntryEditor entryEditor = getEntryEditor(be);</b>
<b class="nc"><i>1156</i>&nbsp;                this.showEntryEditor(entryEditor);</b>
<b class="nc"><i>1157</i>&nbsp;                entryEditor.requestFocus();</b>
<i>1158</i>&nbsp;
<b class="nc"><i>1159</i>&nbsp;                return be;</b>
<b class="nc"><i>1160</i>&nbsp;            } catch (KeyCollisionException ex) {</b>
<b class="nc"><i>1161</i>&nbsp;                LOGGER.info(ex.getMessage(), ex);</b>
<i>1162</i>&nbsp;            }
<i>1163</i>&nbsp;        }
<b class="nc"><i>1164</i>&nbsp;        return null;</b>
<i>1165</i>&nbsp;    }
<i>1166</i>&nbsp;
<b class="nc"><i>1167</i>&nbsp;    private class GroupTreeListener {</b>
<i>1168</i>&nbsp;
<b class="nc"><i>1169</i>&nbsp;        private final Runnable task = new Runnable() {</b>
<i>1170</i>&nbsp;
<i>1171</i>&nbsp;            @Override
<i>1172</i>&nbsp;            public void run() {
<i>1173</i>&nbsp;                // Update group display (for example to reflect that the number of contained entries has changed)
<b class="nc"><i>1174</i>&nbsp;                frame.getGroupSelector().revalidateGroups();</b>
<b class="nc"><i>1175</i>&nbsp;            }</b>
<i>1176</i>&nbsp;
<i>1177</i>&nbsp;        };
<i>1178</i>&nbsp;
<i>1179</i>&nbsp;        /**
<i>1180</i>&nbsp;         * Only access when you have the lock of the task instance
<i>1181</i>&nbsp;         *
<i>1182</i>&nbsp;         * Guarded by &quot;task&quot;
<i>1183</i>&nbsp;         */
<b class="nc"><i>1184</i>&nbsp;        private TimerTask timerTask = new TimerTask() {</b>
<i>1185</i>&nbsp;
<i>1186</i>&nbsp;            @Override
<i>1187</i>&nbsp;            public void run() {
<b class="nc"><i>1188</i>&nbsp;                task.run();</b>
<b class="nc"><i>1189</i>&nbsp;            }</b>
<i>1190</i>&nbsp;        };
<i>1191</i>&nbsp;
<i>1192</i>&nbsp;
<i>1193</i>&nbsp;        @Subscribe
<i>1194</i>&nbsp;        public void listen(EntryAddedEvent addedEntryEvent) {
<i>1195</i>&nbsp;            // if the added entry is an undo don&#39;t add it to the current group
<b class="nc"><i>1196</i>&nbsp;            if (addedEntryEvent.getEntryEventSource() == EntryEventSource.UNDO) {</b>
<b class="nc"><i>1197</i>&nbsp;                scheduleUpdate();</b>
<b class="nc"><i>1198</i>&nbsp;                return;</b>
<i>1199</i>&nbsp;            }
<i>1200</i>&nbsp;
<i>1201</i>&nbsp;            // Automatically add new entry to the selected group (or set of groups)
<b class="nc"><i>1202</i>&nbsp;            if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_ASSIGN_GROUP) &amp;&amp; frame.getGroupSelector().getToggleAction().isSelected()) {</b>
<b class="nc"><i>1203</i>&nbsp;                final List&lt;BibEntry&gt; entries = Collections.singletonList(addedEntryEvent.getBibEntry());</b>
<b class="nc"><i>1204</i>&nbsp;                final TreePath[] selection = frame.getGroupSelector().getGroupsTree().getSelectionPaths();</b>
<b class="nc"><i>1205</i>&nbsp;                if (selection != null) {</b>
<i>1206</i>&nbsp;                    // it is possible that the user selected nothing. Therefore, checked for &quot;!= null&quot;
<b class="nc"><i>1207</i>&nbsp;                    for (final TreePath tree : selection) {</b>
<b class="nc"><i>1208</i>&nbsp;                        ((GroupTreeNodeViewModel) tree.getLastPathComponent()).addEntriesToGroup(entries);</b>
<i>1209</i>&nbsp;                    }
<i>1210</i>&nbsp;                }
<b class="nc"><i>1211</i>&nbsp;                SwingUtilities.invokeLater(() -&gt; BasePanel.this.getGroupSelector().valueChanged(null));</b>
<i>1212</i>&nbsp;            }
<i>1213</i>&nbsp;
<b class="nc"><i>1214</i>&nbsp;            scheduleUpdate();</b>
<b class="nc"><i>1215</i>&nbsp;        }</b>
<i>1216</i>&nbsp;
<i>1217</i>&nbsp;        private void scheduleUpdate() {
<i>1218</i>&nbsp;            // This is a quickfix/dirty hack.
<i>1219</i>&nbsp;            // a better solution would be using RxJava or something reactive instead
<i>1220</i>&nbsp;            // nevertheless it works correctly
<b class="nc"><i>1221</i>&nbsp;            synchronized (task) {</b>
<b class="nc"><i>1222</i>&nbsp;                timerTask.cancel();</b>
<b class="nc"><i>1223</i>&nbsp;                timerTask = new TimerTask() {</b>
<i>1224</i>&nbsp;
<i>1225</i>&nbsp;                    @Override
<i>1226</i>&nbsp;                    public void run() {
<b class="nc"><i>1227</i>&nbsp;                        task.run();</b>
<b class="nc"><i>1228</i>&nbsp;                    }</b>
<i>1229</i>&nbsp;                };
<b class="nc"><i>1230</i>&nbsp;                JabRefExecutorService.INSTANCE.submit(timerTask, 200);</b>
<b class="nc"><i>1231</i>&nbsp;            }</b>
<b class="nc"><i>1232</i>&nbsp;        }</b>
<i>1233</i>&nbsp;    }
<i>1234</i>&nbsp;
<i>1235</i>&nbsp;    /**
<i>1236</i>&nbsp;     * Ensures that the search auto completer is up to date when entries are changed AKA Let the auto completer, if any,
<i>1237</i>&nbsp;     * harvest words from the entry
<i>1238</i>&nbsp;     */
<b class="nc"><i>1239</i>&nbsp;    private class SearchAutoCompleteListener {</b>
<i>1240</i>&nbsp;
<i>1241</i>&nbsp;        @Subscribe
<i>1242</i>&nbsp;        public void listen(EntryAddedEvent addedEntryEvent) {
<b class="nc"><i>1243</i>&nbsp;            searchAutoCompleter.addBibtexEntry(addedEntryEvent.getBibEntry());</b>
<b class="nc"><i>1244</i>&nbsp;        }</b>
<i>1245</i>&nbsp;
<i>1246</i>&nbsp;        @Subscribe
<i>1247</i>&nbsp;        public void listen(EntryChangedEvent entryChangedEvent) {
<b class="nc"><i>1248</i>&nbsp;            searchAutoCompleter.addBibtexEntry(entryChangedEvent.getBibEntry());</b>
<b class="nc"><i>1249</i>&nbsp;        }</b>
<i>1250</i>&nbsp;    }
<i>1251</i>&nbsp;
<i>1252</i>&nbsp;    /**
<i>1253</i>&nbsp;     * Ensures that auto completers are up to date when entries are changed AKA Let the auto completer, if any, harvest
<i>1254</i>&nbsp;     * words from the entry
<i>1255</i>&nbsp;     */
<b class="nc"><i>1256</i>&nbsp;    private class AutoCompleteListener {</b>
<i>1257</i>&nbsp;
<i>1258</i>&nbsp;        @Subscribe
<i>1259</i>&nbsp;        public void listen(EntryAddedEvent addedEntryEvent) {
<b class="nc"><i>1260</i>&nbsp;            BasePanel.this.autoCompleters.addEntry(addedEntryEvent.getBibEntry());</b>
<b class="nc"><i>1261</i>&nbsp;        }</b>
<i>1262</i>&nbsp;
<i>1263</i>&nbsp;        @Subscribe
<i>1264</i>&nbsp;        public void listen(EntryChangedEvent entryChangedEvent) {
<b class="nc"><i>1265</i>&nbsp;            BasePanel.this.autoCompleters.addEntry(entryChangedEvent.getBibEntry());</b>
<b class="nc"><i>1266</i>&nbsp;        }</b>
<i>1267</i>&nbsp;    }
<i>1268</i>&nbsp;
<i>1269</i>&nbsp;    /**
<i>1270</i>&nbsp;     * Ensures that the results of the current search are updated when a new entry is inserted into the database
<i>1271</i>&nbsp;     */
<b class="nc"><i>1272</i>&nbsp;    private class SearchListener {</b>
<i>1273</i>&nbsp;        @Subscribe
<i>1274</i>&nbsp;        public void listen(EntryAddedEvent addedEntryEvent) {
<b class="nc"><i>1275</i>&nbsp;            frame.getGlobalSearchBar().performSearch();</b>
<b class="nc"><i>1276</i>&nbsp;        }</b>
<i>1277</i>&nbsp;
<i>1278</i>&nbsp;        @Subscribe
<i>1279</i>&nbsp;        public void listen(EntryChangedEvent entryChangedEvent) {
<b class="nc"><i>1280</i>&nbsp;            frame.getGlobalSearchBar().setDontSelectSearchBar(true);</b>
<b class="nc"><i>1281</i>&nbsp;            frame.getGlobalSearchBar().performSearch();</b>
<b class="nc"><i>1282</i>&nbsp;        }</b>
<i>1283</i>&nbsp;
<i>1284</i>&nbsp;        @Subscribe
<i>1285</i>&nbsp;        public void listen(EntryRemovedEvent removedEntryEvent) {
<i>1286</i>&nbsp;            // IMO only used to update the status (found X entries)
<b class="nc"><i>1287</i>&nbsp;            frame.getGlobalSearchBar().performSearch();</b>
<b class="nc"><i>1288</i>&nbsp;        }</b>
<i>1289</i>&nbsp;    }
<i>1290</i>&nbsp;
<i>1291</i>&nbsp;
<i>1292</i>&nbsp;    /**
<i>1293</i>&nbsp;     * This method is called from JabRefFrame when the user wants to create a new entry.
<i>1294</i>&nbsp;     *
<i>1295</i>&nbsp;     * @param bibEntry The new entry.
<i>1296</i>&nbsp;     */
<i>1297</i>&nbsp;    public void insertEntry(final BibEntry bibEntry) {
<b class="nc"><i>1298</i>&nbsp;        if (bibEntry != null) {</b>
<i>1299</i>&nbsp;            try {
<b class="nc"><i>1300</i>&nbsp;                bibDatabaseContext.getDatabase().insertEntry(bibEntry);</b>
<b class="nc"><i>1301</i>&nbsp;                if (Globals.prefs.getBoolean(JabRefPreferences.USE_OWNER)) {</b>
<i>1302</i>&nbsp;                    // Set owner field to default value
<b class="nc"><i>1303</i>&nbsp;                    UpdateField.setAutomaticFields(bibEntry, true, true, Globals.prefs.getUpdateFieldPreferences());</b>
<i>1304</i>&nbsp;                }
<i>1305</i>&nbsp;                // Create an UndoableInsertEntry object.
<b class="nc"><i>1306</i>&nbsp;                getUndoManager()</b>
<b class="nc"><i>1307</i>&nbsp;                        .addEdit(new UndoableInsertEntry(bibDatabaseContext.getDatabase(), bibEntry, BasePanel.this));</b>
<b class="nc"><i>1308</i>&nbsp;                output(Localization.lang(&quot;Added new &#39;%0&#39; entry.&quot;, bibEntry.getType()));</b>
<i>1309</i>&nbsp;
<b class="nc"><i>1310</i>&nbsp;                markBaseChanged(); // The database just changed.</b>
<b class="nc"><i>1311</i>&nbsp;                if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_OPEN_FORM)) {</b>
<b class="nc"><i>1312</i>&nbsp;                    selectionListener.editSignalled(bibEntry);</b>
<i>1313</i>&nbsp;                }
<b class="nc"><i>1314</i>&nbsp;                highlightEntry(bibEntry);</b>
<b class="nc"><i>1315</i>&nbsp;            } catch (KeyCollisionException ex) {</b>
<b class="nc"><i>1316</i>&nbsp;                LOGGER.info(&quot;Collision for bibtex key&quot; + bibEntry.getId(), ex);</b>
<b class="nc"><i>1317</i>&nbsp;            }</b>
<i>1318</i>&nbsp;        }
<b class="nc"><i>1319</i>&nbsp;    }</b>
<i>1320</i>&nbsp;
<i>1321</i>&nbsp;    public void editEntryByIdAndFocusField(final String entryId, final String fieldName) {
<b class="nc"><i>1322</i>&nbsp;        final Optional&lt;BibEntry&gt; entry = bibDatabaseContext.getDatabase().getEntryById(entryId);</b>
<b class="nc"><i>1323</i>&nbsp;        entry.ifPresent(e -&gt; {</b>
<b class="nc"><i>1324</i>&nbsp;            mainTable.setSelected(mainTable.findEntry(e));</b>
<b class="nc"><i>1325</i>&nbsp;            selectionListener.editSignalled();</b>
<b class="nc"><i>1326</i>&nbsp;            final EntryEditor editor = getEntryEditor(e);</b>
<b class="nc"><i>1327</i>&nbsp;            editor.setFocusToField(fieldName);</b>
<b class="nc"><i>1328</i>&nbsp;            this.showEntryEditor(editor);</b>
<b class="nc"><i>1329</i>&nbsp;            editor.requestFocus();</b>
<b class="nc"><i>1330</i>&nbsp;        });</b>
<b class="nc"><i>1331</i>&nbsp;    }</b>
<i>1332</i>&nbsp;
<i>1333</i>&nbsp;    public void updateTableFont() {
<b class="nc"><i>1334</i>&nbsp;        mainTable.updateFont();</b>
<b class="nc"><i>1335</i>&nbsp;    }</b>
<i>1336</i>&nbsp;
<i>1337</i>&nbsp;    private void createMainTable() {
<b class="nc"><i>1338</i>&nbsp;        bibDatabaseContext.getDatabase().registerListener(tableModel.getListSynchronizer());</b>
<b class="nc"><i>1339</i>&nbsp;        bibDatabaseContext.getDatabase().registerListener(SpecialFieldDatabaseChangeListener.getInstance());</b>
<i>1340</i>&nbsp;
<b class="nc"><i>1341</i>&nbsp;        tableFormat = new MainTableFormat(bibDatabaseContext.getDatabase());</b>
<b class="nc"><i>1342</i>&nbsp;        tableFormat.updateTableFormat();</b>
<b class="nc"><i>1343</i>&nbsp;        mainTable = new MainTable(tableFormat, tableModel, frame, this);</b>
<i>1344</i>&nbsp;
<b class="nc"><i>1345</i>&nbsp;        selectionListener = new MainTableSelectionListener(this, mainTable);</b>
<b class="nc"><i>1346</i>&nbsp;        mainTable.updateFont();</b>
<b class="nc"><i>1347</i>&nbsp;        mainTable.addSelectionListener(selectionListener);</b>
<b class="nc"><i>1348</i>&nbsp;        mainTable.addMouseListener(selectionListener);</b>
<b class="nc"><i>1349</i>&nbsp;        mainTable.addKeyListener(selectionListener);</b>
<b class="nc"><i>1350</i>&nbsp;        mainTable.addFocusListener(selectionListener);</b>
<i>1351</i>&nbsp;
<i>1352</i>&nbsp;        // Add the listener that will take care of highlighting groups as the selection changes:
<b class="nc"><i>1353</i>&nbsp;        groupsHighlightListener = listEvent -&gt; {</b>
<b class="nc"><i>1354</i>&nbsp;            HighlightMatchingGroupPreferences highlightMatchingGroupPreferences = new HighlightMatchingGroupPreferences(</b>
<i>1355</i>&nbsp;                    Globals.prefs);
<b class="nc"><i>1356</i>&nbsp;            if (highlightMatchingGroupPreferences.isAny()) {</b>
<b class="nc"><i>1357</i>&nbsp;                getGroupSelector().showMatchingGroups(mainTable.getSelectedEntries(), false);</b>
<b class="nc"><i>1358</i>&nbsp;            } else if (highlightMatchingGroupPreferences.isAll()) {</b>
<b class="nc"><i>1359</i>&nbsp;                getGroupSelector().showMatchingGroups(mainTable.getSelectedEntries(), true);</b>
<i>1360</i>&nbsp;            } else {
<i>1361</i>&nbsp;                // no highlight
<b class="nc"><i>1362</i>&nbsp;                getGroupSelector().showMatchingGroups(null, true);</b>
<i>1363</i>&nbsp;            }
<b class="nc"><i>1364</i>&nbsp;        };</b>
<b class="nc"><i>1365</i>&nbsp;        mainTable.addSelectionListener(groupsHighlightListener);</b>
<i>1366</i>&nbsp;
<b class="nc"><i>1367</i>&nbsp;        String clearSearch = &quot;clearSearch&quot;;</b>
<b class="nc"><i>1368</i>&nbsp;        mainTable.getInputMap().put(Globals.getKeyPrefs().getKey(KeyBinding.CLEAR_SEARCH), clearSearch);</b>
<b class="nc"><i>1369</i>&nbsp;        mainTable.getActionMap().put(clearSearch, new AbstractAction() {</b>
<i>1370</i>&nbsp;            @Override
<i>1371</i>&nbsp;            public void actionPerformed(ActionEvent e) {
<i>1372</i>&nbsp;                // need to close these here, b/c this action overshadows the responsible actions when the main table is selected
<b class="nc"><i>1373</i>&nbsp;                switch (mode) {</b>
<i>1374</i>&nbsp;                    case SHOWING_NOTHING:
<b class="nc"><i>1375</i>&nbsp;                        frame.getGlobalSearchBar().endSearch();</b>
<b class="nc"><i>1376</i>&nbsp;                        break;</b>
<i>1377</i>&nbsp;                    case SHOWING_PREVIEW:
<b class="nc"><i>1378</i>&nbsp;                        getPreviewPanel().close();</b>
<b class="nc"><i>1379</i>&nbsp;                        break;</b>
<i>1380</i>&nbsp;                    case SHOWING_EDITOR:
<i>1381</i>&nbsp;                    case WILL_SHOW_EDITOR:
<b class="nc"><i>1382</i>&nbsp;                        getCurrentEditor().close();</b>
<b class="nc"><i>1383</i>&nbsp;                        break;</b>
<i>1384</i>&nbsp;                    default:
<b class="nc"><i>1385</i>&nbsp;                        LOGGER.warn(&quot;unknown BasePanelMode: &#39;&quot; + mode + &quot;&#39;, doing nothing&quot;);</b>
<i>1386</i>&nbsp;                        break;
<i>1387</i>&nbsp;                }
<b class="nc"><i>1388</i>&nbsp;            }</b>
<i>1389</i>&nbsp;        });
<i>1390</i>&nbsp;
<b class="nc"><i>1391</i>&nbsp;        mainTable.getActionMap().put(Actions.CUT, new AbstractAction() {</b>
<i>1392</i>&nbsp;
<i>1393</i>&nbsp;            @Override
<i>1394</i>&nbsp;            public void actionPerformed(ActionEvent e) {
<i>1395</i>&nbsp;                try {
<b class="nc"><i>1396</i>&nbsp;                    runCommand(Actions.CUT);</b>
<b class="nc"><i>1397</i>&nbsp;                } catch (Throwable ex) {</b>
<b class="nc"><i>1398</i>&nbsp;                    LOGGER.warn(&quot;Could not cut&quot;, ex);</b>
<b class="nc"><i>1399</i>&nbsp;                }</b>
<b class="nc"><i>1400</i>&nbsp;            }</b>
<i>1401</i>&nbsp;        });
<b class="nc"><i>1402</i>&nbsp;        mainTable.getActionMap().put(Actions.COPY, new AbstractAction() {</b>
<i>1403</i>&nbsp;
<i>1404</i>&nbsp;            @Override
<i>1405</i>&nbsp;            public void actionPerformed(ActionEvent e) {
<i>1406</i>&nbsp;                try {
<b class="nc"><i>1407</i>&nbsp;                    runCommand(Actions.COPY);</b>
<b class="nc"><i>1408</i>&nbsp;                } catch (Throwable ex) {</b>
<b class="nc"><i>1409</i>&nbsp;                    LOGGER.warn(&quot;Could not copy&quot;, ex);</b>
<b class="nc"><i>1410</i>&nbsp;                }</b>
<b class="nc"><i>1411</i>&nbsp;            }</b>
<i>1412</i>&nbsp;        });
<b class="nc"><i>1413</i>&nbsp;        mainTable.getActionMap().put(Actions.PASTE, new AbstractAction() {</b>
<i>1414</i>&nbsp;
<i>1415</i>&nbsp;            @Override
<i>1416</i>&nbsp;            public void actionPerformed(ActionEvent e) {
<i>1417</i>&nbsp;                try {
<b class="nc"><i>1418</i>&nbsp;                    runCommand(Actions.PASTE);</b>
<b class="nc"><i>1419</i>&nbsp;                } catch (Throwable ex) {</b>
<b class="nc"><i>1420</i>&nbsp;                    LOGGER.warn(&quot;Could not paste&quot;, ex);</b>
<b class="nc"><i>1421</i>&nbsp;                }</b>
<b class="nc"><i>1422</i>&nbsp;            }</b>
<i>1423</i>&nbsp;        });
<i>1424</i>&nbsp;
<b class="nc"><i>1425</i>&nbsp;        mainTable.addKeyListener(new KeyAdapter() {</b>
<i>1426</i>&nbsp;
<i>1427</i>&nbsp;            @Override
<i>1428</i>&nbsp;            public void keyPressed(KeyEvent e) {
<b class="nc"><i>1429</i>&nbsp;                final int keyCode = e.getKeyCode();</b>
<b class="nc"><i>1430</i>&nbsp;                final TreePath path = frame.getGroupSelector().getSelectionPath();</b>
<b class="nc"><i>1431</i>&nbsp;                final GroupTreeNodeViewModel node = path == null ? null : (GroupTreeNodeViewModel) path</b>
<b class="nc"><i>1432</i>&nbsp;                        .getLastPathComponent();</b>
<i>1433</i>&nbsp;
<b class="nc"><i>1434</i>&nbsp;                if (e.isControlDown()) {</b>
<b class="nc"><i>1435</i>&nbsp;                    switch (keyCode) {</b>
<i>1436</i>&nbsp;                    // The up/down/left/rightkeystrokes are displayed in the
<i>1437</i>&nbsp;                    // GroupSelector&#39;s popup menu, so if they are to be changed,
<i>1438</i>&nbsp;                    // edit GroupSelector.java accordingly!
<i>1439</i>&nbsp;                    case KeyEvent.VK_UP:
<b class="nc"><i>1440</i>&nbsp;                        e.consume();</b>
<b class="nc"><i>1441</i>&nbsp;                        if (node != null) {</b>
<b class="nc"><i>1442</i>&nbsp;                            frame.getGroupSelector().moveNodeUp(node, true);</b>
<i>1443</i>&nbsp;                        }
<i>1444</i>&nbsp;                        break;
<i>1445</i>&nbsp;                    case KeyEvent.VK_DOWN:
<b class="nc"><i>1446</i>&nbsp;                        e.consume();</b>
<b class="nc"><i>1447</i>&nbsp;                        if (node != null) {</b>
<b class="nc"><i>1448</i>&nbsp;                            frame.getGroupSelector().moveNodeDown(node, true);</b>
<i>1449</i>&nbsp;                        }
<i>1450</i>&nbsp;                        break;
<i>1451</i>&nbsp;                    case KeyEvent.VK_LEFT:
<b class="nc"><i>1452</i>&nbsp;                        e.consume();</b>
<b class="nc"><i>1453</i>&nbsp;                        if (node != null) {</b>
<b class="nc"><i>1454</i>&nbsp;                            frame.getGroupSelector().moveNodeLeft(node, true);</b>
<i>1455</i>&nbsp;                        }
<i>1456</i>&nbsp;                        break;
<i>1457</i>&nbsp;                    case KeyEvent.VK_RIGHT:
<b class="nc"><i>1458</i>&nbsp;                        e.consume();</b>
<b class="nc"><i>1459</i>&nbsp;                        if (node != null) {</b>
<b class="nc"><i>1460</i>&nbsp;                            frame.getGroupSelector().moveNodeRight(node, true);</b>
<i>1461</i>&nbsp;                        }
<i>1462</i>&nbsp;                        break;
<i>1463</i>&nbsp;                    case KeyEvent.VK_PAGE_DOWN:
<b class="nc"><i>1464</i>&nbsp;                        frame.nextTab.actionPerformed(null);</b>
<b class="nc"><i>1465</i>&nbsp;                        e.consume();</b>
<b class="nc"><i>1466</i>&nbsp;                        break;</b>
<i>1467</i>&nbsp;                    case KeyEvent.VK_PAGE_UP:
<b class="nc"><i>1468</i>&nbsp;                        frame.prevTab.actionPerformed(null);</b>
<b class="nc"><i>1469</i>&nbsp;                        e.consume();</b>
<b class="nc"><i>1470</i>&nbsp;                        break;</b>
<i>1471</i>&nbsp;                    default:
<b class="nc"><i>1472</i>&nbsp;                        break;</b>
<i>1473</i>&nbsp;                    }
<b class="nc"><i>1474</i>&nbsp;                } else if (keyCode == KeyEvent.VK_ENTER) {</b>
<b class="nc"><i>1475</i>&nbsp;                    e.consume();</b>
<i>1476</i>&nbsp;                    try {
<b class="nc"><i>1477</i>&nbsp;                        runCommand(Actions.EDIT);</b>
<b class="nc"><i>1478</i>&nbsp;                    } catch (Throwable ex) {</b>
<b class="nc"><i>1479</i>&nbsp;                        LOGGER.warn(&quot;Could not run action based on key press&quot;, ex);</b>
<b class="nc"><i>1480</i>&nbsp;                    }</b>
<i>1481</i>&nbsp;                }
<b class="nc"><i>1482</i>&nbsp;            }</b>
<i>1483</i>&nbsp;        });
<b class="nc"><i>1484</i>&nbsp;    }</b>
<i>1485</i>&nbsp;
<i>1486</i>&nbsp;    public void setupMainPanel() {
<b class="nc"><i>1487</i>&nbsp;        splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);</b>
<b class="nc"><i>1488</i>&nbsp;        splitPane.setDividerSize(SPLIT_PANE_DIVIDER_SIZE);</b>
<b class="nc"><i>1489</i>&nbsp;        adjustSplitter(); // restore last splitting state (before mainTable is created as creation affects the stored size of the entryEditors)</b>
<i>1490</i>&nbsp;
<i>1491</i>&nbsp;        // check whether a mainTable already existed and a floatSearch was active
<b class="nc"><i>1492</i>&nbsp;        boolean floatSearchActive = (mainTable != null)</b>
<b class="nc"><i>1493</i>&nbsp;                &amp;&amp; (this.tableModel.getSearchState() == MainTableDataModel.DisplayOption.FLOAT);</b>
<i>1494</i>&nbsp;
<b class="nc"><i>1495</i>&nbsp;        createMainTable();</b>
<i>1496</i>&nbsp;
<b class="nc"><i>1497</i>&nbsp;        splitPane.setTopComponent(mainTable.getPane());</b>
<i>1498</i>&nbsp;
<i>1499</i>&nbsp;        // Remove borders
<b class="nc"><i>1500</i>&nbsp;        splitPane.setBorder(BorderFactory.createEmptyBorder());</b>
<b class="nc"><i>1501</i>&nbsp;        setBorder(BorderFactory.createEmptyBorder());</b>
<i>1502</i>&nbsp;
<i>1503</i>&nbsp;        // If an entry is currently being shown, make sure it stays shown,
<i>1504</i>&nbsp;        // otherwise set the bottom component to null.
<b class="nc"><i>1505</i>&nbsp;        if (mode == BasePanelMode.SHOWING_PREVIEW) {</b>
<b class="nc"><i>1506</i>&nbsp;            mode = BasePanelMode.SHOWING_NOTHING;</b>
<b class="nc"><i>1507</i>&nbsp;            highlightEntry(selectionListener.getPreview().getEntry());</b>
<b class="nc"><i>1508</i>&nbsp;        } else if (mode == BasePanelMode.SHOWING_EDITOR) {</b>
<b class="nc"><i>1509</i>&nbsp;            mode = BasePanelMode.SHOWING_NOTHING;</b>
<i>1510</i>&nbsp;        } else {
<b class="nc"><i>1511</i>&nbsp;            splitPane.setBottomComponent(null);</b>
<i>1512</i>&nbsp;        }
<i>1513</i>&nbsp;
<b class="nc"><i>1514</i>&nbsp;        setLayout(new BorderLayout());</b>
<b class="nc"><i>1515</i>&nbsp;        removeAll();</b>
<b class="nc"><i>1516</i>&nbsp;        add(splitPane, BorderLayout.CENTER);</b>
<i>1517</i>&nbsp;
<i>1518</i>&nbsp;        // Set up name autocompleter for search:
<b class="nc"><i>1519</i>&nbsp;        instantiateSearchAutoCompleter();</b>
<b class="nc"><i>1520</i>&nbsp;        this.getDatabase().registerListener(new SearchAutoCompleteListener());</b>
<i>1521</i>&nbsp;
<b class="nc"><i>1522</i>&nbsp;        AutoCompletePreferences autoCompletePreferences = new AutoCompletePreferences(Globals.prefs);</b>
<i>1523</i>&nbsp;        // Set up AutoCompleters for this panel:
<b class="nc"><i>1524</i>&nbsp;        if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_COMPLETE)) {</b>
<b class="nc"><i>1525</i>&nbsp;            autoCompleters = new ContentAutoCompleters(getDatabase(), bibDatabaseContext.getMetaData(),</b>
<i>1526</i>&nbsp;                    autoCompletePreferences, Globals.journalAbbreviationLoader);
<i>1527</i>&nbsp;            // ensure that the autocompleters are in sync with entries
<b class="nc"><i>1528</i>&nbsp;            this.getDatabase().registerListener(new AutoCompleteListener());</b>
<i>1529</i>&nbsp;        } else {
<i>1530</i>&nbsp;            // create empty ContentAutoCompleters() if autoCompletion is deactivated
<b class="nc"><i>1531</i>&nbsp;            autoCompleters = new ContentAutoCompleters();</b>
<i>1532</i>&nbsp;        }
<i>1533</i>&nbsp;
<i>1534</i>&nbsp;        // restore floating search result
<i>1535</i>&nbsp;        // (needed if preferences have been changed which causes a recreation of the main table)
<b class="nc"><i>1536</i>&nbsp;        if (floatSearchActive) {</b>
<b class="nc"><i>1537</i>&nbsp;            mainTable.showFloatSearch();</b>
<i>1538</i>&nbsp;        }
<i>1539</i>&nbsp;
<b class="nc"><i>1540</i>&nbsp;        splitPane.revalidate();</b>
<b class="nc"><i>1541</i>&nbsp;        revalidate();</b>
<b class="nc"><i>1542</i>&nbsp;        repaint();</b>
<i>1543</i>&nbsp;
<i>1544</i>&nbsp;        // saves the divider position as soon as it changes
<b class="nc"><i>1545</i>&nbsp;        splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, event -&gt; saveDividerLocation());</b>
<b class="nc"><i>1546</i>&nbsp;    }</b>
<i>1547</i>&nbsp;
<i>1548</i>&nbsp;    public void updateSearchManager() {
<b class="nc"><i>1549</i>&nbsp;        frame.getGlobalSearchBar().setAutoCompleter(searchAutoCompleter);</b>
<b class="nc"><i>1550</i>&nbsp;    }</b>
<i>1551</i>&nbsp;
<i>1552</i>&nbsp;    private void instantiateSearchAutoCompleter() {
<b class="nc"><i>1553</i>&nbsp;        AutoCompletePreferences autoCompletePreferences = new AutoCompletePreferences(Globals.prefs);</b>
<b class="nc"><i>1554</i>&nbsp;        AutoCompleterFactory autoCompleterFactory = new AutoCompleterFactory(autoCompletePreferences,</b>
<i>1555</i>&nbsp;                Globals.journalAbbreviationLoader);
<b class="nc"><i>1556</i>&nbsp;        searchAutoCompleter = autoCompleterFactory.getPersonAutoCompleter();</b>
<b class="nc"><i>1557</i>&nbsp;        for (BibEntry entry : bibDatabaseContext.getDatabase().getEntries()) {</b>
<b class="nc"><i>1558</i>&nbsp;            searchAutoCompleter.addBibtexEntry(entry);</b>
<b class="nc"><i>1559</i>&nbsp;        }</b>
<b class="nc"><i>1560</i>&nbsp;    }</b>
<i>1561</i>&nbsp;
<i>1562</i>&nbsp;    public void updatePreamble() {
<b class="nc"><i>1563</i>&nbsp;        if (preambleEditor != null) {</b>
<b class="nc"><i>1564</i>&nbsp;            preambleEditor.updatePreamble();</b>
<i>1565</i>&nbsp;        }
<b class="nc"><i>1566</i>&nbsp;    }</b>
<i>1567</i>&nbsp;
<i>1568</i>&nbsp;    public void assureStringDialogNotEditing() {
<b class="nc"><i>1569</i>&nbsp;        if (stringDialog != null) {</b>
<b class="nc"><i>1570</i>&nbsp;            stringDialog.assureNotEditing();</b>
<i>1571</i>&nbsp;        }
<b class="nc"><i>1572</i>&nbsp;    }</b>
<i>1573</i>&nbsp;
<i>1574</i>&nbsp;    public void updateStringDialog() {
<b class="nc"><i>1575</i>&nbsp;        if (stringDialog != null) {</b>
<b class="nc"><i>1576</i>&nbsp;            stringDialog.refreshTable();</b>
<i>1577</i>&nbsp;        }
<b class="nc"><i>1578</i>&nbsp;    }</b>
<i>1579</i>&nbsp;
<i>1580</i>&nbsp;    public void adjustSplitter() {
<b class="nc"><i>1581</i>&nbsp;        if (mode == BasePanelMode.SHOWING_PREVIEW) {</b>
<b class="nc"><i>1582</i>&nbsp;            splitPane.setDividerLocation(</b>
<b class="nc"><i>1583</i>&nbsp;                    splitPane.getHeight() - Globals.prefs.getPreviewPreferences().getPreviewPanelHeight());</b>
<i>1584</i>&nbsp;        } else {
<b class="nc"><i>1585</i>&nbsp;            splitPane.setDividerLocation(</b>
<b class="nc"><i>1586</i>&nbsp;                    splitPane.getHeight() - Globals.prefs.getInt(JabRefPreferences.ENTRY_EDITOR_HEIGHT));</b>
<i>1587</i>&nbsp;
<i>1588</i>&nbsp;        }
<b class="nc"><i>1589</i>&nbsp;    }</b>
<i>1590</i>&nbsp;
<i>1591</i>&nbsp;    private boolean isShowingEditor() {
<b class="nc"><i>1592</i>&nbsp;        return (splitPane.getBottomComponent() != null) &amp;&amp; (splitPane.getBottomComponent() instanceof EntryEditor);</b>
<i>1593</i>&nbsp;    }
<i>1594</i>&nbsp;
<i>1595</i>&nbsp;    public void showEntry(final BibEntry be) {
<i>1596</i>&nbsp;
<b class="nc"><i>1597</i>&nbsp;        if (getShowing() == be) {</b>
<b class="nc"><i>1598</i>&nbsp;            if (splitPane.getBottomComponent() == null) {</b>
<i>1599</i>&nbsp;                // This is the special occasion when showing is set to an
<i>1600</i>&nbsp;                // entry, but no entry editor is in fact shown. This happens
<i>1601</i>&nbsp;                // after Preferences dialog is closed, and it means that we
<i>1602</i>&nbsp;                // must make sure the same entry is shown again. We do this by
<i>1603</i>&nbsp;                // setting showing to null, and recursively calling this method.
<b class="nc"><i>1604</i>&nbsp;                newEntryShowing(null);</b>
<b class="nc"><i>1605</i>&nbsp;                showEntry(be);</b>
<i>1606</i>&nbsp;            } else {
<i>1607</i>&nbsp;                // The correct entry is already being shown. Make sure the editor
<i>1608</i>&nbsp;                // is updated.
<b class="nc"><i>1609</i>&nbsp;                ((EntryEditor) splitPane.getBottomComponent()).updateAllFields();</b>
<i>1610</i>&nbsp;
<i>1611</i>&nbsp;            }
<b class="nc"><i>1612</i>&nbsp;            return;</b>
<i>1613</i>&nbsp;
<i>1614</i>&nbsp;        }
<i>1615</i>&nbsp;
<b class="nc"><i>1616</i>&nbsp;        String visName = null;</b>
<b class="nc"><i>1617</i>&nbsp;        if ((getShowing() != null) &amp;&amp; isShowingEditor()) {</b>
<b class="nc"><i>1618</i>&nbsp;            visName = ((EntryEditor) splitPane.getBottomComponent()).getVisiblePanelName();</b>
<i>1619</i>&nbsp;        }
<i>1620</i>&nbsp;
<i>1621</i>&nbsp;        // We must instantiate a new editor.
<b class="nc"><i>1622</i>&nbsp;        EntryEditor entryEditor = new EntryEditor(frame, BasePanel.this, be);</b>
<b class="nc"><i>1623</i>&nbsp;        if (visName != null) {</b>
<b class="nc"><i>1624</i>&nbsp;            entryEditor.setVisiblePanel(visName);</b>
<i>1625</i>&nbsp;        }
<b class="nc"><i>1626</i>&nbsp;        showEntryEditor(entryEditor);</b>
<i>1627</i>&nbsp;
<b class="nc"><i>1628</i>&nbsp;        newEntryShowing(be);</b>
<b class="nc"><i>1629</i>&nbsp;        setEntryEditorEnabled(true); // Make sure it is enabled.</b>
<b class="nc"><i>1630</i>&nbsp;    }</b>
<i>1631</i>&nbsp;
<i>1632</i>&nbsp;    /**
<i>1633</i>&nbsp;     * Get an entry editor ready to edit the given entry. If an appropriate editor is already cached, it will be updated
<i>1634</i>&nbsp;     * and returned.
<i>1635</i>&nbsp;     *
<i>1636</i>&nbsp;     * @param entry The entry to be edited.
<i>1637</i>&nbsp;     * @return A suitable entry editor.
<i>1638</i>&nbsp;     */
<i>1639</i>&nbsp;    public EntryEditor getEntryEditor(BibEntry entry) {
<i>1640</i>&nbsp;        // We must instantiate a new editor. First make sure the old one stores its last edit:
<b class="nc"><i>1641</i>&nbsp;        storeCurrentEdit();</b>
<i>1642</i>&nbsp;        // Then start the new one:
<b class="nc"><i>1643</i>&nbsp;        return new EntryEditor(frame, BasePanel.this, entry);</b>
<i>1644</i>&nbsp;    }
<i>1645</i>&nbsp;
<i>1646</i>&nbsp;    public EntryEditor getCurrentEditor() {
<b class="nc"><i>1647</i>&nbsp;        return currentEditor;</b>
<i>1648</i>&nbsp;    }
<i>1649</i>&nbsp;
<i>1650</i>&nbsp;    /**
<i>1651</i>&nbsp;     * Sets the given entry editor as the bottom component in the split pane. If an entry editor already was shown,
<i>1652</i>&nbsp;     * makes sure that the divider doesn&#39;t move. Updates the mode to SHOWING_EDITOR.
<i>1653</i>&nbsp;     *
<i>1654</i>&nbsp;     * @param editor The entry editor to add.
<i>1655</i>&nbsp;     */
<i>1656</i>&nbsp;    public void showEntryEditor(EntryEditor editor) {
<b class="nc"><i>1657</i>&nbsp;        if (mode == BasePanelMode.SHOWING_EDITOR) {</b>
<b class="nc"><i>1658</i>&nbsp;            Globals.prefs.putInt(JabRefPreferences.ENTRY_EDITOR_HEIGHT,</b>
<b class="nc"><i>1659</i>&nbsp;                    splitPane.getHeight() - splitPane.getDividerLocation());</b>
<i>1660</i>&nbsp;        }
<b class="nc"><i>1661</i>&nbsp;        mode = BasePanelMode.SHOWING_EDITOR;</b>
<b class="nc"><i>1662</i>&nbsp;        if (currentEditor != null) {</b>
<b class="nc"><i>1663</i>&nbsp;            currentEditor.setMovingToDifferentEntry();</b>
<i>1664</i>&nbsp;        }
<b class="nc"><i>1665</i>&nbsp;        currentEditor = editor;</b>
<b class="nc"><i>1666</i>&nbsp;        splitPane.setBottomComponent(editor);</b>
<b class="nc"><i>1667</i>&nbsp;        if (editor.getEntry() != getShowing()) {</b>
<b class="nc"><i>1668</i>&nbsp;            newEntryShowing(editor.getEntry());</b>
<i>1669</i>&nbsp;        }
<b class="nc"><i>1670</i>&nbsp;        adjustSplitter();</b>
<b class="nc"><i>1671</i>&nbsp;    }</b>
<i>1672</i>&nbsp;
<i>1673</i>&nbsp;    /**
<i>1674</i>&nbsp;     * Sets the given preview panel as the bottom component in the split panel. Updates the mode to SHOWING_PREVIEW.
<i>1675</i>&nbsp;     *
<i>1676</i>&nbsp;     * @param preview The preview to show.
<i>1677</i>&nbsp;     */
<i>1678</i>&nbsp;    public void showPreview(PreviewPanel preview) {
<b class="nc"><i>1679</i>&nbsp;        mode = BasePanelMode.SHOWING_PREVIEW;</b>
<b class="nc"><i>1680</i>&nbsp;        splitPane.setBottomComponent(preview);</b>
<b class="nc"><i>1681</i>&nbsp;        adjustSplitter();</b>
<b class="nc"><i>1682</i>&nbsp;    }</b>
<i>1683</i>&nbsp;
<i>1684</i>&nbsp;    /**
<i>1685</i>&nbsp;     * Removes the bottom component.
<i>1686</i>&nbsp;     */
<i>1687</i>&nbsp;    public void hideBottomComponent() {
<b class="nc"><i>1688</i>&nbsp;        mode = BasePanelMode.SHOWING_NOTHING;</b>
<b class="nc"><i>1689</i>&nbsp;        splitPane.setBottomComponent(null);</b>
<b class="nc"><i>1690</i>&nbsp;    }</b>
<i>1691</i>&nbsp;
<i>1692</i>&nbsp;    /**
<i>1693</i>&nbsp;     * This method selects the given entry, and scrolls it into view in the table. If an entryEditor is shown, it is
<i>1694</i>&nbsp;     * given focus afterwards.
<i>1695</i>&nbsp;     */
<i>1696</i>&nbsp;    public void highlightEntry(final BibEntry bibEntry) {
<b class="nc"><i>1697</i>&nbsp;        highlightEntry(mainTable.findEntry(bibEntry));</b>
<b class="nc"><i>1698</i>&nbsp;    }</b>
<i>1699</i>&nbsp;
<i>1700</i>&nbsp;    /**
<i>1701</i>&nbsp;     * This method selects the entry on the given position, and scrolls it into view in the table.
<i>1702</i>&nbsp;     * If an entryEditor is shown, it is given focus afterwards.
<i>1703</i>&nbsp;     */
<i>1704</i>&nbsp;    public void highlightEntry(int pos) {
<b class="nc"><i>1705</i>&nbsp;        if ((pos &gt;= 0) &amp;&amp; (pos &lt; mainTable.getRowCount())) {</b>
<b class="nc"><i>1706</i>&nbsp;            mainTable.setRowSelectionInterval(pos, pos);</b>
<b class="nc"><i>1707</i>&nbsp;            mainTable.ensureVisible(pos);</b>
<i>1708</i>&nbsp;        }
<b class="nc"><i>1709</i>&nbsp;    }</b>
<i>1710</i>&nbsp;
<i>1711</i>&nbsp;    public void selectPreviousEntry() {
<b class="nc"><i>1712</i>&nbsp;        highlightEntry(((mainTable.getSelectedRow() - 1) + mainTable.getRowCount()) % mainTable.getRowCount());</b>
<b class="nc"><i>1713</i>&nbsp;    }</b>
<i>1714</i>&nbsp;
<i>1715</i>&nbsp;    public void selectNextEntry() {
<b class="nc"><i>1716</i>&nbsp;        highlightEntry((mainTable.getSelectedRow() + 1) % mainTable.getRowCount());</b>
<b class="nc"><i>1717</i>&nbsp;    }</b>
<i>1718</i>&nbsp;
<i>1719</i>&nbsp;    public void selectFirstEntry() {
<b class="nc"><i>1720</i>&nbsp;        highlightEntry(0);</b>
<b class="nc"><i>1721</i>&nbsp;    }</b>
<i>1722</i>&nbsp;
<i>1723</i>&nbsp;    public void selectLastEntry() {
<b class="nc"><i>1724</i>&nbsp;        highlightEntry(mainTable.getRowCount() - 1);</b>
<b class="nc"><i>1725</i>&nbsp;    }</b>
<i>1726</i>&nbsp;
<i>1727</i>&nbsp;    /**
<i>1728</i>&nbsp;     * This method is called from an EntryEditor when it should be closed. We relay to the selection listener, which
<i>1729</i>&nbsp;     * takes care of the rest.
<i>1730</i>&nbsp;     *
<i>1731</i>&nbsp;     * @param editor The entry editor to close.
<i>1732</i>&nbsp;     */
<i>1733</i>&nbsp;    public void entryEditorClosing(EntryEditor editor) {
<i>1734</i>&nbsp;        // Store divider location for next time:
<b class="nc"><i>1735</i>&nbsp;        Globals.prefs.putInt(JabRefPreferences.ENTRY_EDITOR_HEIGHT,</b>
<b class="nc"><i>1736</i>&nbsp;                splitPane.getHeight() - splitPane.getDividerLocation());</b>
<b class="nc"><i>1737</i>&nbsp;        selectionListener.entryEditorClosing(editor);</b>
<b class="nc"><i>1738</i>&nbsp;    }</b>
<i>1739</i>&nbsp;
<i>1740</i>&nbsp;    /**
<i>1741</i>&nbsp;     * Closes the entry editor or preview panel if it is showing the given entry.
<i>1742</i>&nbsp;     */
<i>1743</i>&nbsp;    public void ensureNotShowingBottomPanel(BibEntry entry) {
<b class="nc"><i>1744</i>&nbsp;        if (((mode == BasePanelMode.SHOWING_EDITOR) &amp;&amp; (currentEditor.getEntry() == entry))</b>
<b class="nc"><i>1745</i>&nbsp;                || ((mode == BasePanelMode.SHOWING_PREVIEW) &amp;&amp; (selectionListener.getPreview().getEntry() == entry))) {</b>
<b class="nc"><i>1746</i>&nbsp;            hideBottomComponent();</b>
<i>1747</i>&nbsp;        }
<b class="nc"><i>1748</i>&nbsp;    }</b>
<i>1749</i>&nbsp;
<i>1750</i>&nbsp;    public void updateEntryEditorIfShowing() {
<b class="nc"><i>1751</i>&nbsp;        if (mode == BasePanelMode.SHOWING_EDITOR) {</b>
<b class="nc"><i>1752</i>&nbsp;            if (currentEditor.getDisplayedBibEntryType().equals(currentEditor.getEntry().getType())) {</b>
<b class="nc"><i>1753</i>&nbsp;                currentEditor.updateAllFields();</b>
<b class="nc"><i>1754</i>&nbsp;                currentEditor.updateSource();</b>
<i>1755</i>&nbsp;            } else {
<i>1756</i>&nbsp;                // The entry has changed type, so we must get a new editor.
<b class="nc"><i>1757</i>&nbsp;                newEntryShowing(null);</b>
<b class="nc"><i>1758</i>&nbsp;                final EntryEditor newEditor = getEntryEditor(currentEditor.getEntry());</b>
<b class="nc"><i>1759</i>&nbsp;                showEntryEditor(newEditor);</b>
<i>1760</i>&nbsp;            }
<i>1761</i>&nbsp;        }
<b class="nc"><i>1762</i>&nbsp;    }</b>
<i>1763</i>&nbsp;
<i>1764</i>&nbsp;    /**
<i>1765</i>&nbsp;     * If an entry editor is showing, make sure its currently focused field stores its changes, if any.
<i>1766</i>&nbsp;     */
<i>1767</i>&nbsp;    public void storeCurrentEdit() {
<b class="nc"><i>1768</i>&nbsp;        if (isShowingEditor()) {</b>
<b class="nc"><i>1769</i>&nbsp;            final EntryEditor editor = (EntryEditor) splitPane.getBottomComponent();</b>
<b class="nc"><i>1770</i>&nbsp;            editor.storeCurrentEdit();</b>
<i>1771</i>&nbsp;        }
<b class="nc"><i>1772</i>&nbsp;    }</b>
<i>1773</i>&nbsp;
<i>1774</i>&nbsp;    public void markBaseChanged() {
<b class="nc"><i>1775</i>&nbsp;        baseChanged = true;</b>
<i>1776</i>&nbsp;
<b class="nc"><i>1777</i>&nbsp;        if (SwingUtilities.isEventDispatchThread()) {</b>
<b class="nc"><i>1778</i>&nbsp;            markBasedChangedInternal();</b>
<i>1779</i>&nbsp;        } else {
<i>1780</i>&nbsp;            try {
<b class="nc"><i>1781</i>&nbsp;                SwingUtilities.invokeAndWait(() -&gt; markBasedChangedInternal());</b>
<b class="nc"><i>1782</i>&nbsp;            } catch (InvocationTargetException | InterruptedException e) {</b>
<b class="nc"><i>1783</i>&nbsp;                LOGGER.info(&quot;Problem marking database as changed&quot;, e);</b>
<b class="nc"><i>1784</i>&nbsp;            }</b>
<i>1785</i>&nbsp;        }
<i>1786</i>&nbsp;
<b class="nc"><i>1787</i>&nbsp;    }</b>
<i>1788</i>&nbsp;
<i>1789</i>&nbsp;    private void markBasedChangedInternal() {
<i>1790</i>&nbsp;        // Put an asterisk behind the filename to indicate the database has changed.
<b class="nc"><i>1791</i>&nbsp;        frame.setWindowTitle();</b>
<b class="nc"><i>1792</i>&nbsp;        frame.updateAllTabTitles();</b>
<i>1793</i>&nbsp;        // If the status line states that the base has been saved, we
<i>1794</i>&nbsp;        // remove this message, since it is no longer relevant. If a
<i>1795</i>&nbsp;        // different message is shown, we leave it.
<b class="nc"><i>1796</i>&nbsp;        if (frame.getStatusLineText().startsWith(Localization.lang(&quot;Saved database&quot;))) {</b>
<b class="nc"><i>1797</i>&nbsp;            frame.output(&quot; &quot;);</b>
<i>1798</i>&nbsp;        }
<b class="nc"><i>1799</i>&nbsp;    }</b>
<i>1800</i>&nbsp;
<i>1801</i>&nbsp;    public void markNonUndoableBaseChanged() {
<b class="nc"><i>1802</i>&nbsp;        nonUndoableChange = true;</b>
<b class="nc"><i>1803</i>&nbsp;        markBaseChanged();</b>
<b class="nc"><i>1804</i>&nbsp;    }</b>
<i>1805</i>&nbsp;
<i>1806</i>&nbsp;    public void rebuildAllEntryEditors() {
<b class="nc"><i>1807</i>&nbsp;        currentEditor.rebuildPanels();</b>
<b class="nc"><i>1808</i>&nbsp;    }</b>
<i>1809</i>&nbsp;
<i>1810</i>&nbsp;    private synchronized void markChangedOrUnChanged() {
<b class="nc"><i>1811</i>&nbsp;        if (getUndoManager().hasChanged()) {</b>
<b class="nc"><i>1812</i>&nbsp;            if (!baseChanged) {</b>
<b class="nc"><i>1813</i>&nbsp;                markBaseChanged();</b>
<i>1814</i>&nbsp;            }
<b class="nc"><i>1815</i>&nbsp;        } else if (baseChanged &amp;&amp; !nonUndoableChange) {</b>
<b class="nc"><i>1816</i>&nbsp;            baseChanged = false;</b>
<b class="nc"><i>1817</i>&nbsp;            if (getBibDatabaseContext().getDatabaseFile().isPresent()) {</b>
<b class="nc"><i>1818</i>&nbsp;                frame.setTabTitle(this, getTabTitle(),</b>
<b class="nc"><i>1819</i>&nbsp;                        getBibDatabaseContext().getDatabaseFile().get().getAbsolutePath());</b>
<i>1820</i>&nbsp;            } else {
<b class="nc"><i>1821</i>&nbsp;                frame.setTabTitle(this, GUIGlobals.UNTITLED_TITLE, null);</b>
<i>1822</i>&nbsp;            }
<i>1823</i>&nbsp;        }
<b class="nc"><i>1824</i>&nbsp;        frame.setWindowTitle();</b>
<b class="nc"><i>1825</i>&nbsp;    }</b>
<i>1826</i>&nbsp;
<i>1827</i>&nbsp;    public BibDatabase getDatabase() {
<b class="nc"><i>1828</i>&nbsp;        return bibDatabaseContext.getDatabase();</b>
<i>1829</i>&nbsp;    }
<i>1830</i>&nbsp;
<i>1831</i>&nbsp;    public void preambleEditorClosing() {
<b class="nc"><i>1832</i>&nbsp;        preambleEditor = null;</b>
<b class="nc"><i>1833</i>&nbsp;    }</b>
<i>1834</i>&nbsp;
<i>1835</i>&nbsp;    public void stringsClosing() {
<b class="nc"><i>1836</i>&nbsp;        stringDialog = null;</b>
<b class="nc"><i>1837</i>&nbsp;    }</b>
<i>1838</i>&nbsp;
<i>1839</i>&nbsp;    public void changeTypeOfSelectedEntries(String newType) {
<b class="nc"><i>1840</i>&nbsp;        List&lt;BibEntry&gt; bes = mainTable.getSelectedEntries();</b>
<b class="nc"><i>1841</i>&nbsp;        changeType(bes, newType);</b>
<b class="nc"><i>1842</i>&nbsp;    }</b>
<i>1843</i>&nbsp;
<i>1844</i>&nbsp;    private void changeType(List&lt;BibEntry&gt; entries, String newType) {
<b class="nc"><i>1845</i>&nbsp;        if ((entries == null) || (entries.isEmpty())) {</b>
<b class="nc"><i>1846</i>&nbsp;            LOGGER.error(&quot;At least one entry must be selected to be able to change the type.&quot;);</b>
<b class="nc"><i>1847</i>&nbsp;            return;</b>
<i>1848</i>&nbsp;        }
<i>1849</i>&nbsp;
<b class="nc"><i>1850</i>&nbsp;        if (entries.size() &gt; 1) {</b>
<b class="nc"><i>1851</i>&nbsp;            int choice = JOptionPane.showConfirmDialog(this,</b>
<b class="nc"><i>1852</i>&nbsp;                    Localization.lang(&quot;Multiple entries selected. Do you want to change the type of all these to &#39;%0&#39;?&quot;,</b>
<i>1853</i>&nbsp;                            newType),
<b class="nc"><i>1854</i>&nbsp;                    Localization.lang(&quot;Change entry type&quot;), JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);</b>
<b class="nc"><i>1855</i>&nbsp;            if (choice == JOptionPane.NO_OPTION) {</b>
<b class="nc"><i>1856</i>&nbsp;                return;</b>
<i>1857</i>&nbsp;            }
<i>1858</i>&nbsp;        }
<i>1859</i>&nbsp;
<b class="nc"><i>1860</i>&nbsp;        NamedCompound compound = new NamedCompound(Localization.lang(&quot;Change entry type&quot;));</b>
<b class="nc"><i>1861</i>&nbsp;        for (BibEntry entry : entries) {</b>
<b class="nc"><i>1862</i>&nbsp;            compound.addEdit(new UndoableChangeType(entry, entry.getType(), newType));</b>
<b class="nc"><i>1863</i>&nbsp;            entry.setType(newType);</b>
<b class="nc"><i>1864</i>&nbsp;        }</b>
<i>1865</i>&nbsp;
<b class="nc"><i>1866</i>&nbsp;        output(formatOutputMessage(Localization.lang(&quot;Changed type to &#39;%0&#39; for&quot;, newType), entries.size()));</b>
<b class="nc"><i>1867</i>&nbsp;        compound.end();</b>
<b class="nc"><i>1868</i>&nbsp;        getUndoManager().addEdit(compound);</b>
<b class="nc"><i>1869</i>&nbsp;        markBaseChanged();</b>
<b class="nc"><i>1870</i>&nbsp;        updateEntryEditorIfShowing();</b>
<b class="nc"><i>1871</i>&nbsp;    }</b>
<i>1872</i>&nbsp;
<i>1873</i>&nbsp;    public boolean showDeleteConfirmationDialog(int numberOfEntries) {
<b class="nc"><i>1874</i>&nbsp;        if (Globals.prefs.getBoolean(JabRefPreferences.CONFIRM_DELETE)) {</b>
<i>1875</i>&nbsp;            String msg;
<b class="nc"><i>1876</i>&nbsp;            msg = Localization.lang(&quot;Really delete the selected entry?&quot;);</b>
<b class="nc"><i>1877</i>&nbsp;            String title = Localization.lang(&quot;Delete entry&quot;);</b>
<b class="nc"><i>1878</i>&nbsp;            if (numberOfEntries &gt; 1) {</b>
<b class="nc"><i>1879</i>&nbsp;                msg = Localization.lang(&quot;Really delete the %0 selected entries?&quot;, Integer.toString(numberOfEntries));</b>
<b class="nc"><i>1880</i>&nbsp;                title = Localization.lang(&quot;Delete multiple entries&quot;);</b>
<i>1881</i>&nbsp;            }
<i>1882</i>&nbsp;
<b class="nc"><i>1883</i>&nbsp;            CheckBoxMessage cb = new CheckBoxMessage(msg, Localization.lang(&quot;Disable this confirmation dialog&quot;), false);</b>
<i>1884</i>&nbsp;
<b class="nc"><i>1885</i>&nbsp;            int answer = JOptionPane.showConfirmDialog(frame, cb, title, JOptionPane.YES_NO_OPTION,</b>
<i>1886</i>&nbsp;                    JOptionPane.QUESTION_MESSAGE);
<b class="nc"><i>1887</i>&nbsp;            if (cb.isSelected()) {</b>
<b class="nc"><i>1888</i>&nbsp;                Globals.prefs.putBoolean(JabRefPreferences.CONFIRM_DELETE, false);</b>
<i>1889</i>&nbsp;            }
<b class="nc"><i>1890</i>&nbsp;            return answer == JOptionPane.YES_OPTION;</b>
<i>1891</i>&nbsp;        } else {
<b class="nc"><i>1892</i>&nbsp;            return true;</b>
<i>1893</i>&nbsp;        }
<i>1894</i>&nbsp;
<i>1895</i>&nbsp;    }
<i>1896</i>&nbsp;
<i>1897</i>&nbsp;    /**
<i>1898</i>&nbsp;     * If the relevant option is set, autogenerate keys for all entries that are lacking keys.
<i>1899</i>&nbsp;     */
<i>1900</i>&nbsp;    public void autoGenerateKeysBeforeSaving() {
<b class="nc"><i>1901</i>&nbsp;        if (Globals.prefs.getBoolean(JabRefPreferences.GENERATE_KEYS_BEFORE_SAVING)) {</b>
<b class="nc"><i>1902</i>&nbsp;            NamedCompound ce = new NamedCompound(Localization.lang(&quot;Autogenerate BibTeX keys&quot;));</b>
<i>1903</i>&nbsp;
<b class="nc"><i>1904</i>&nbsp;            for (BibEntry bes : bibDatabaseContext.getDatabase().getEntries()) {</b>
<b class="nc"><i>1905</i>&nbsp;                Optional&lt;String&gt; oldKey = bes.getCiteKeyOptional();</b>
<b class="nc"><i>1906</i>&nbsp;                if (!(oldKey.isPresent()) || oldKey.get().isEmpty()) {</b>
<b class="nc"><i>1907</i>&nbsp;                    BibtexKeyPatternUtil.makeAndSetLabel(bibDatabaseContext.getMetaData()</b>
<b class="nc"><i>1908</i>&nbsp;                            .getCiteKeyPattern(Globals.prefs.getBibtexKeyPatternPreferences().getKeyPattern()),</b>
<b class="nc"><i>1909</i>&nbsp;                            bibDatabaseContext.getDatabase(),</b>
<b class="nc"><i>1910</i>&nbsp;                            bes, Globals.prefs.getBibtexKeyPatternPreferences());</b>
<b class="nc"><i>1911</i>&nbsp;                    bes.getCiteKeyOptional().ifPresent(</b>
<b class="nc"><i>1912</i>&nbsp;                            newKey -&gt; ce.addEdit(new UndoableKeyChange(bes, oldKey.orElse(&quot;&quot;), newKey)));</b>
<i>1913</i>&nbsp;                }
<b class="nc"><i>1914</i>&nbsp;            }</b>
<i>1915</i>&nbsp;
<i>1916</i>&nbsp;            // Store undo information, if any:
<b class="nc"><i>1917</i>&nbsp;            if (ce.hasEdits()) {</b>
<b class="nc"><i>1918</i>&nbsp;                ce.end();</b>
<b class="nc"><i>1919</i>&nbsp;                getUndoManager().addEdit(ce);</b>
<i>1920</i>&nbsp;            }
<i>1921</i>&nbsp;        }
<b class="nc"><i>1922</i>&nbsp;    }</b>
<i>1923</i>&nbsp;
<i>1924</i>&nbsp;    /**
<i>1925</i>&nbsp;     * Activates or deactivates the entry preview, depending on the argument. When deactivating, makes sure that any
<i>1926</i>&nbsp;     * visible preview is hidden.
<i>1927</i>&nbsp;     *
<i>1928</i>&nbsp;     * @param enabled
<i>1929</i>&nbsp;     */
<i>1930</i>&nbsp;    private void setPreviewActive(boolean enabled) {
<b class="nc"><i>1931</i>&nbsp;        selectionListener.setPreviewActive(enabled);</b>
<b class="nc"><i>1932</i>&nbsp;    }</b>
<i>1933</i>&nbsp;
<i>1934</i>&nbsp;    /**
<i>1935</i>&nbsp;     * Depending on whether a preview or an entry editor is showing, save the current divider location in the correct
<i>1936</i>&nbsp;     * preference setting.
<i>1937</i>&nbsp;     */
<i>1938</i>&nbsp;    public void saveDividerLocation() {
<b class="nc"><i>1939</i>&nbsp;        if (mode == BasePanelMode.SHOWING_PREVIEW) {</b>
<b class="nc"><i>1940</i>&nbsp;            int previewPanelHeight = splitPane.getHeight() - splitPane.getDividerLocation();</b>
<b class="nc"><i>1941</i>&nbsp;            PreviewPreferences previewPreferences = Globals.prefs.getPreviewPreferences()</b>
<b class="nc"><i>1942</i>&nbsp;                    .getBuilder()</b>
<b class="nc"><i>1943</i>&nbsp;                    .withPreviewPanelHeight(previewPanelHeight)</b>
<b class="nc"><i>1944</i>&nbsp;                    .build();</b>
<b class="nc"><i>1945</i>&nbsp;            Globals.prefs.storePreviewPreferences(previewPreferences);</b>
<b class="nc"><i>1946</i>&nbsp;        } else if (mode == BasePanelMode.SHOWING_EDITOR) {</b>
<b class="nc"><i>1947</i>&nbsp;            Globals.prefs.putInt(JabRefPreferences.ENTRY_EDITOR_HEIGHT,</b>
<b class="nc"><i>1948</i>&nbsp;                    splitPane.getHeight() - splitPane.getDividerLocation());</b>
<i>1949</i>&nbsp;        }
<b class="nc"><i>1950</i>&nbsp;    }</b>
<i>1951</i>&nbsp;
<i>1952</i>&nbsp;
<b class="nc"><i>1953</i>&nbsp;    private class UndoAction implements BaseAction {</b>
<i>1954</i>&nbsp;
<i>1955</i>&nbsp;        @Override
<i>1956</i>&nbsp;        public void action() {
<i>1957</i>&nbsp;            try {
<b class="nc"><i>1958</i>&nbsp;                JComponent focused = Globals.getFocusListener().getFocused();</b>
<b class="nc"><i>1959</i>&nbsp;                if ((focused != null) &amp;&amp; (focused instanceof FieldEditor) &amp;&amp; focused.hasFocus()) {</b>
<i>1960</i>&nbsp;                    // User is currently editing a field:
<i>1961</i>&nbsp;                    // Check if it is the preamble:
<b class="nc"><i>1962</i>&nbsp;                    if ((preambleEditor != null) &amp;&amp; (focused == preambleEditor.getFieldEditor())) {</b>
<b class="nc"><i>1963</i>&nbsp;                        preambleEditor.storeCurrentEdit();</b>
<i>1964</i>&nbsp;                    } else {
<b class="nc"><i>1965</i>&nbsp;                        storeCurrentEdit();</b>
<i>1966</i>&nbsp;                    }
<i>1967</i>&nbsp;                }
<b class="nc"><i>1968</i>&nbsp;                getUndoManager().undo();</b>
<b class="nc"><i>1969</i>&nbsp;                markBaseChanged();</b>
<b class="nc"><i>1970</i>&nbsp;                frame.output(Localization.lang(&quot;Undo&quot;));</b>
<b class="nc"><i>1971</i>&nbsp;            } catch (CannotUndoException ex) {</b>
<b class="nc"><i>1972</i>&nbsp;                LOGGER.warn(&quot;Nothing to undo&quot;, ex);</b>
<b class="nc"><i>1973</i>&nbsp;                frame.output(Localization.lang(&quot;Nothing to undo&quot;) + &#39;.&#39;);</b>
<b class="nc"><i>1974</i>&nbsp;            }</b>
<i>1975</i>&nbsp;
<b class="nc"><i>1976</i>&nbsp;            markChangedOrUnChanged();</b>
<b class="nc"><i>1977</i>&nbsp;        }</b>
<i>1978</i>&nbsp;    }
<i>1979</i>&nbsp;
<b class="nc"><i>1980</i>&nbsp;    private class OpenURLAction implements BaseAction {</b>
<i>1981</i>&nbsp;
<i>1982</i>&nbsp;        @Override
<i>1983</i>&nbsp;        public void action() {
<b class="nc"><i>1984</i>&nbsp;            final List&lt;BibEntry&gt; bes = mainTable.getSelectedEntries();</b>
<b class="nc"><i>1985</i>&nbsp;            if (bes.size() == 1) {</b>
<b class="nc"><i>1986</i>&nbsp;                String field = FieldName.DOI;</b>
<b class="nc"><i>1987</i>&nbsp;                Optional&lt;String&gt; link = bes.get(0).getField(FieldName.DOI);</b>
<b class="nc"><i>1988</i>&nbsp;                if (bes.get(0).hasField(FieldName.URL)) {</b>
<b class="nc"><i>1989</i>&nbsp;                    link = bes.get(0).getField(FieldName.URL);</b>
<b class="nc"><i>1990</i>&nbsp;                    field = FieldName.URL;</b>
<i>1991</i>&nbsp;                }
<b class="nc"><i>1992</i>&nbsp;                if (link.isPresent()) {</b>
<i>1993</i>&nbsp;                    try {
<b class="nc"><i>1994</i>&nbsp;                        JabRefDesktop.openExternalViewer(bibDatabaseContext, link.get(), field);</b>
<b class="nc"><i>1995</i>&nbsp;                        output(Localization.lang(&quot;External viewer called&quot;) + &#39;.&#39;);</b>
<b class="nc"><i>1996</i>&nbsp;                    } catch (IOException ex) {</b>
<b class="nc"><i>1997</i>&nbsp;                        output(Localization.lang(&quot;Error&quot;) + &quot;: &quot; + ex.getMessage());</b>
<b class="nc"><i>1998</i>&nbsp;                    }</b>
<i>1999</i>&nbsp;                } else {
<i>2000</i>&nbsp;                    // No URL or DOI found in the &quot;url&quot; and &quot;doi&quot; fields.
<i>2001</i>&nbsp;                    // Look for web links in the &quot;file&quot; field as a fallback:
<b class="nc"><i>2002</i>&nbsp;                    FileListEntry entry = null;</b>
<b class="nc"><i>2003</i>&nbsp;                    FileListTableModel tm = new FileListTableModel();</b>
<b class="nc"><i>2004</i>&nbsp;                    bes.get(0).getField(FieldName.FILE).ifPresent(tm::setContent);</b>
<b class="nc"><i>2005</i>&nbsp;                    for (int i = 0; i &lt; tm.getRowCount(); i++) {</b>
<b class="nc"><i>2006</i>&nbsp;                        FileListEntry flEntry = tm.getEntry(i);</b>
<b class="nc"><i>2007</i>&nbsp;                        if (FieldName.URL.equalsIgnoreCase(flEntry.type.get().getName())</b>
<b class="nc"><i>2008</i>&nbsp;                                || FieldName.PS.equalsIgnoreCase(flEntry.type.get().getName())</b>
<b class="nc"><i>2009</i>&nbsp;                                || FieldName.PDF.equalsIgnoreCase(flEntry.type.get().getName())) {</b>
<b class="nc"><i>2010</i>&nbsp;                            entry = flEntry;</b>
<b class="nc"><i>2011</i>&nbsp;                            break;</b>
<i>2012</i>&nbsp;                        }
<i>2013</i>&nbsp;                    }
<b class="nc"><i>2014</i>&nbsp;                    if (entry == null) {</b>
<b class="nc"><i>2015</i>&nbsp;                        output(Localization.lang(&quot;No URL defined&quot;) + &#39;.&#39;);</b>
<i>2016</i>&nbsp;                    } else {
<i>2017</i>&nbsp;                        try {
<b class="nc"><i>2018</i>&nbsp;                            JabRefDesktop.openExternalFileAnyFormat(bibDatabaseContext, entry.link, entry.type);</b>
<b class="nc"><i>2019</i>&nbsp;                            output(Localization.lang(&quot;External viewer called&quot;) + &#39;.&#39;);</b>
<b class="nc"><i>2020</i>&nbsp;                        } catch (IOException e) {</b>
<b class="nc"><i>2021</i>&nbsp;                            output(Localization.lang(&quot;Could not open link&quot;));</b>
<b class="nc"><i>2022</i>&nbsp;                            LOGGER.info(&quot;Could not open link&quot;, e);</b>
<b class="nc"><i>2023</i>&nbsp;                        }</b>
<i>2024</i>&nbsp;                    }
<i>2025</i>&nbsp;                }
<b class="nc"><i>2026</i>&nbsp;            } else {</b>
<b class="nc"><i>2027</i>&nbsp;                output(Localization.lang(&quot;This operation requires exactly one item to be selected.&quot;));</b>
<i>2028</i>&nbsp;            }
<i>2029</i>&nbsp;
<b class="nc"><i>2030</i>&nbsp;        }</b>
<i>2031</i>&nbsp;    }
<i>2032</i>&nbsp;
<b class="nc"><i>2033</i>&nbsp;    private class RedoAction implements BaseAction {</b>
<i>2034</i>&nbsp;
<i>2035</i>&nbsp;        @Override
<i>2036</i>&nbsp;        public void action() {
<i>2037</i>&nbsp;            try {
<i>2038</i>&nbsp;
<b class="nc"><i>2039</i>&nbsp;                JComponent focused = Globals.getFocusListener().getFocused();</b>
<b class="nc"><i>2040</i>&nbsp;                if ((focused != null) &amp;&amp; (focused instanceof FieldEditor) &amp;&amp; focused.hasFocus()) {</b>
<i>2041</i>&nbsp;                    // User is currently editing a field:
<b class="nc"><i>2042</i>&nbsp;                    storeCurrentEdit();</b>
<i>2043</i>&nbsp;                }
<i>2044</i>&nbsp;
<b class="nc"><i>2045</i>&nbsp;                getUndoManager().redo();</b>
<b class="nc"><i>2046</i>&nbsp;                markBaseChanged();</b>
<b class="nc"><i>2047</i>&nbsp;                frame.output(Localization.lang(&quot;Redo&quot;));</b>
<b class="nc"><i>2048</i>&nbsp;            } catch (CannotRedoException ex) {</b>
<b class="nc"><i>2049</i>&nbsp;                frame.output(Localization.lang(&quot;Nothing to redo&quot;) + &#39;.&#39;);</b>
<b class="nc"><i>2050</i>&nbsp;            }</b>
<i>2051</i>&nbsp;
<b class="nc"><i>2052</i>&nbsp;            markChangedOrUnChanged();</b>
<b class="nc"><i>2053</i>&nbsp;        }</b>
<i>2054</i>&nbsp;    }
<i>2055</i>&nbsp;
<b class="nc"><i>2056</i>&nbsp;    private class PrintPreviewAction implements BaseAction {</b>
<i>2057</i>&nbsp;
<i>2058</i>&nbsp;        @Override
<i>2059</i>&nbsp;        public void action() throws Exception {
<b class="nc"><i>2060</i>&nbsp;            selectionListener.setPreviewActive(true);</b>
<b class="nc"><i>2061</i>&nbsp;            showPreview(selectionListener.getPreview());</b>
<b class="nc"><i>2062</i>&nbsp;            selectionListener.getPreview().getPrintAction().actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, null));</b>
<b class="nc"><i>2063</i>&nbsp;        }</b>
<i>2064</i>&nbsp;    }
<i>2065</i>&nbsp;
<i>2066</i>&nbsp;    // Method pertaining to the ClipboardOwner interface.
<i>2067</i>&nbsp;    @Override
<i>2068</i>&nbsp;    public void lostOwnership(Clipboard clipboard, Transferable contents) {
<i>2069</i>&nbsp;        // Nothing
<b class="nc"><i>2070</i>&nbsp;    }</b>
<i>2071</i>&nbsp;
<i>2072</i>&nbsp;    private void setEntryEditorEnabled(boolean enabled) {
<b class="nc"><i>2073</i>&nbsp;        if ((getShowing() != null) &amp;&amp; (splitPane.getBottomComponent() instanceof EntryEditor)) {</b>
<b class="nc"><i>2074</i>&nbsp;            EntryEditor ed = (EntryEditor) splitPane.getBottomComponent();</b>
<b class="nc"><i>2075</i>&nbsp;            if (ed.isEnabled() != enabled) {</b>
<b class="nc"><i>2076</i>&nbsp;                ed.setEnabled(enabled);</b>
<i>2077</i>&nbsp;            }
<i>2078</i>&nbsp;        }
<b class="nc"><i>2079</i>&nbsp;    }</b>
<i>2080</i>&nbsp;
<i>2081</i>&nbsp;    public String fileMonitorHandle() {
<b class="nc"><i>2082</i>&nbsp;        return fileMonitorHandle;</b>
<i>2083</i>&nbsp;    }
<i>2084</i>&nbsp;
<i>2085</i>&nbsp;    @Override
<i>2086</i>&nbsp;    public void fileUpdated() {
<b class="nc"><i>2087</i>&nbsp;        if (saving) {</b>
<i>2088</i>&nbsp;            // We are just saving the file, so this message is most likely due to bad timing.
<i>2089</i>&nbsp;            // If not, we&#39;ll handle it on the next polling.
<b class="nc"><i>2090</i>&nbsp;            return;</b>
<i>2091</i>&nbsp;        }
<i>2092</i>&nbsp;
<b class="nc"><i>2093</i>&nbsp;        updatedExternally = true;</b>
<i>2094</i>&nbsp;
<b class="nc"><i>2095</i>&nbsp;        final ChangeScanner scanner = new ChangeScanner(frame, BasePanel.this,</b>
<b class="nc"><i>2096</i>&nbsp;                getBibDatabaseContext().getDatabaseFile().orElse(null));</b>
<i>2097</i>&nbsp;
<i>2098</i>&nbsp;        // Test: running scan automatically in background
<b class="nc"><i>2099</i>&nbsp;        if ((getBibDatabaseContext().getDatabaseFile().isPresent())</b>
<b class="nc"><i>2100</i>&nbsp;                &amp;&amp; !FileBasedLock.waitForFileLock(getBibDatabaseContext().getDatabaseFile().get().toPath())) {</b>
<i>2101</i>&nbsp;            // The file is locked even after the maximum wait. Do nothing.
<b class="nc"><i>2102</i>&nbsp;            LOGGER.error(&quot;File updated externally, but change scan failed because the file is locked.&quot;);</b>
<i>2103</i>&nbsp;            // Perturb the stored timestamp so successive checks are made:
<b class="nc"><i>2104</i>&nbsp;            Globals.getFileUpdateMonitor().perturbTimestamp(getFileMonitorHandle());</b>
<b class="nc"><i>2105</i>&nbsp;            return;</b>
<i>2106</i>&nbsp;        }
<i>2107</i>&nbsp;
<b class="nc"><i>2108</i>&nbsp;        JabRefExecutorService.INSTANCE.executeInterruptableTaskAndWait(scanner);</b>
<i>2109</i>&nbsp;
<i>2110</i>&nbsp;        // Adding the sidepane component is Swing work, so we must do this in the Swing
<i>2111</i>&nbsp;        // thread:
<b class="nc"><i>2112</i>&nbsp;        Runnable t = () -&gt; {</b>
<i>2113</i>&nbsp;
<i>2114</i>&nbsp;            // Check if there is already a notification about external
<i>2115</i>&nbsp;            // changes:
<b class="nc"><i>2116</i>&nbsp;            boolean hasAlready = sidePaneManager.hasComponent(FileUpdatePanel.class);</b>
<b class="nc"><i>2117</i>&nbsp;            if (hasAlready) {</b>
<b class="nc"><i>2118</i>&nbsp;                sidePaneManager.hideComponent(FileUpdatePanel.class);</b>
<b class="nc"><i>2119</i>&nbsp;                sidePaneManager.unregisterComponent(FileUpdatePanel.class);</b>
<i>2120</i>&nbsp;            }
<b class="nc"><i>2121</i>&nbsp;            FileUpdatePanel pan = new FileUpdatePanel(BasePanel.this, sidePaneManager,</b>
<b class="nc"><i>2122</i>&nbsp;                    getBibDatabaseContext().getDatabaseFile().orElse(null), scanner);</b>
<b class="nc"><i>2123</i>&nbsp;            sidePaneManager.register(pan);</b>
<b class="nc"><i>2124</i>&nbsp;            sidePaneManager.show(FileUpdatePanel.class);</b>
<b class="nc"><i>2125</i>&nbsp;        };</b>
<i>2126</i>&nbsp;
<b class="nc"><i>2127</i>&nbsp;        if (scanner.changesFound()) {</b>
<b class="nc"><i>2128</i>&nbsp;            SwingUtilities.invokeLater(t);</b>
<i>2129</i>&nbsp;        } else {
<b class="nc"><i>2130</i>&nbsp;            setUpdatedExternally(false);</b>
<i>2131</i>&nbsp;        }
<b class="nc"><i>2132</i>&nbsp;    }</b>
<i>2133</i>&nbsp;
<i>2134</i>&nbsp;    @Override
<i>2135</i>&nbsp;    public void fileRemoved() {
<b class="nc"><i>2136</i>&nbsp;        LOGGER.info(&quot;File &#39;&quot; + getBibDatabaseContext().getDatabaseFile().get().getPath() + &quot;&#39; has been deleted.&quot;);</b>
<b class="nc"><i>2137</i>&nbsp;    }</b>
<i>2138</i>&nbsp;
<i>2139</i>&nbsp;    /**
<i>2140</i>&nbsp;     * Perform necessary cleanup when this BasePanel is closed.
<i>2141</i>&nbsp;     */
<i>2142</i>&nbsp;    public void cleanUp() {
<b class="nc"><i>2143</i>&nbsp;        if (fileMonitorHandle != null) {</b>
<b class="nc"><i>2144</i>&nbsp;            Globals.getFileUpdateMonitor().removeUpdateListener(fileMonitorHandle);</b>
<i>2145</i>&nbsp;        }
<i>2146</i>&nbsp;        // Check if there is a FileUpdatePanel for this BasePanel being shown. If so,
<i>2147</i>&nbsp;        // remove it:
<b class="nc"><i>2148</i>&nbsp;        if (sidePaneManager.hasComponent(FileUpdatePanel.class)) {</b>
<b class="nc"><i>2149</i>&nbsp;            FileUpdatePanel fup = (FileUpdatePanel) sidePaneManager.getComponent(FileUpdatePanel.class);</b>
<b class="nc"><i>2150</i>&nbsp;            if (fup.getPanel() == this) {</b>
<b class="nc"><i>2151</i>&nbsp;                sidePaneManager.hideComponent(FileUpdatePanel.class);</b>
<i>2152</i>&nbsp;            }
<i>2153</i>&nbsp;        }
<b class="nc"><i>2154</i>&nbsp;    }</b>
<i>2155</i>&nbsp;
<i>2156</i>&nbsp;    public void setUpdatedExternally(boolean b) {
<b class="nc"><i>2157</i>&nbsp;        updatedExternally = b;</b>
<b class="nc"><i>2158</i>&nbsp;    }</b>
<i>2159</i>&nbsp;
<i>2160</i>&nbsp;    /**
<i>2161</i>&nbsp;     * Get an array containing the currently selected entries. The array is stable and not changed if the selection
<i>2162</i>&nbsp;     * changes
<i>2163</i>&nbsp;     *
<i>2164</i>&nbsp;     * @return A list containing the selected entries. Is never null.
<i>2165</i>&nbsp;     */
<i>2166</i>&nbsp;    public List&lt;BibEntry&gt; getSelectedEntries() {
<b class="nc"><i>2167</i>&nbsp;        return mainTable.getSelectedEntries();</b>
<i>2168</i>&nbsp;    }
<i>2169</i>&nbsp;
<i>2170</i>&nbsp;    public BibDatabaseContext getBibDatabaseContext() {
<b class="nc"><i>2171</i>&nbsp;        return this.bibDatabaseContext;</b>
<i>2172</i>&nbsp;    }
<i>2173</i>&nbsp;
<i>2174</i>&nbsp;    public GroupSelector getGroupSelector() {
<b class="nc"><i>2175</i>&nbsp;        return frame.getGroupSelector();</b>
<i>2176</i>&nbsp;    }
<i>2177</i>&nbsp;
<i>2178</i>&nbsp;    public boolean isUpdatedExternally() {
<b class="nc"><i>2179</i>&nbsp;        return updatedExternally;</b>
<i>2180</i>&nbsp;    }
<i>2181</i>&nbsp;
<i>2182</i>&nbsp;    public String getFileMonitorHandle() {
<b class="nc"><i>2183</i>&nbsp;        return fileMonitorHandle;</b>
<i>2184</i>&nbsp;    }
<i>2185</i>&nbsp;
<i>2186</i>&nbsp;    public void setFileMonitorHandle(String fileMonitorHandle) {
<b class="nc"><i>2187</i>&nbsp;        this.fileMonitorHandle = fileMonitorHandle;</b>
<b class="nc"><i>2188</i>&nbsp;    }</b>
<i>2189</i>&nbsp;
<i>2190</i>&nbsp;    public SidePaneManager getSidePaneManager() {
<b class="nc"><i>2191</i>&nbsp;        return sidePaneManager;</b>
<i>2192</i>&nbsp;    }
<i>2193</i>&nbsp;
<i>2194</i>&nbsp;    public void setNonUndoableChange(boolean nonUndoableChange) {
<b class="nc"><i>2195</i>&nbsp;        this.nonUndoableChange = nonUndoableChange;</b>
<b class="nc"><i>2196</i>&nbsp;    }</b>
<i>2197</i>&nbsp;
<i>2198</i>&nbsp;    public void setBaseChanged(boolean baseChanged) {
<b class="nc"><i>2199</i>&nbsp;        this.baseChanged = baseChanged;</b>
<b class="nc"><i>2200</i>&nbsp;    }</b>
<i>2201</i>&nbsp;
<i>2202</i>&nbsp;    public void setSaving(boolean saving) {
<b class="nc"><i>2203</i>&nbsp;        this.saving = saving;</b>
<b class="nc"><i>2204</i>&nbsp;    }</b>
<i>2205</i>&nbsp;
<i>2206</i>&nbsp;    public boolean isSaving() {
<b class="nc"><i>2207</i>&nbsp;        return saving;</b>
<i>2208</i>&nbsp;    }
<i>2209</i>&nbsp;
<i>2210</i>&nbsp;    private BibEntry getShowing() {
<b class="nc"><i>2211</i>&nbsp;        return showing;</b>
<i>2212</i>&nbsp;    }
<i>2213</i>&nbsp;
<i>2214</i>&nbsp;    /**
<i>2215</i>&nbsp;     * Update the pointer to the currently shown entry in all cases where the user has moved to a new entry, except when
<i>2216</i>&nbsp;     * using Back and Forward commands. Also updates history for Back command, and clears history for Forward command.
<i>2217</i>&nbsp;     *
<i>2218</i>&nbsp;     * @param entry The entry that is now to be shown.
<i>2219</i>&nbsp;     */
<i>2220</i>&nbsp;    public void newEntryShowing(BibEntry entry) {
<i>2221</i>&nbsp;
<i>2222</i>&nbsp;        // If this call is the result of a Back or Forward operation, we must take
<i>2223</i>&nbsp;        // care not to make any history changes, since the necessary changes will
<i>2224</i>&nbsp;        // already have been done in the back() or forward() method:
<b class="nc"><i>2225</i>&nbsp;        if (backOrForwardInProgress) {</b>
<b class="nc"><i>2226</i>&nbsp;            showing = entry;</b>
<b class="nc"><i>2227</i>&nbsp;            backOrForwardInProgress = false;</b>
<b class="nc"><i>2228</i>&nbsp;            setBackAndForwardEnabledState();</b>
<b class="nc"><i>2229</i>&nbsp;            return;</b>
<i>2230</i>&nbsp;        }
<b class="nc"><i>2231</i>&nbsp;        nextEntries.clear();</b>
<b class="nc"><i>2232</i>&nbsp;        if (!Objects.equals(entry, showing)) {</b>
<i>2233</i>&nbsp;            // Add the entry we are leaving to the history:
<b class="nc"><i>2234</i>&nbsp;            if (showing != null) {</b>
<b class="nc"><i>2235</i>&nbsp;                previousEntries.add(showing);</b>
<b class="nc"><i>2236</i>&nbsp;                if (previousEntries.size() &gt; GUIGlobals.MAX_BACK_HISTORY_SIZE) {</b>
<b class="nc"><i>2237</i>&nbsp;                    previousEntries.remove(0);</b>
<i>2238</i>&nbsp;                }
<i>2239</i>&nbsp;            }
<b class="nc"><i>2240</i>&nbsp;            showing = entry;</b>
<b class="nc"><i>2241</i>&nbsp;            setBackAndForwardEnabledState();</b>
<i>2242</i>&nbsp;        }
<i>2243</i>&nbsp;
<b class="nc"><i>2244</i>&nbsp;    }</b>
<i>2245</i>&nbsp;
<i>2246</i>&nbsp;    /**
<i>2247</i>&nbsp;     * Go back (if there is any recorded history) and update the histories for the Back and Forward commands.
<i>2248</i>&nbsp;     */
<i>2249</i>&nbsp;    private void back() {
<b class="nc"><i>2250</i>&nbsp;        if (!previousEntries.isEmpty()) {</b>
<b class="nc"><i>2251</i>&nbsp;            BibEntry toShow = previousEntries.get(previousEntries.size() - 1);</b>
<b class="nc"><i>2252</i>&nbsp;            previousEntries.remove(previousEntries.size() - 1);</b>
<i>2253</i>&nbsp;            // Add the entry we are going back from to the Forward history:
<b class="nc"><i>2254</i>&nbsp;            if (showing != null) {</b>
<b class="nc"><i>2255</i>&nbsp;                nextEntries.add(showing);</b>
<i>2256</i>&nbsp;            }
<b class="nc"><i>2257</i>&nbsp;            backOrForwardInProgress = true; // to avoid the history getting updated erroneously</b>
<b class="nc"><i>2258</i>&nbsp;            highlightEntry(toShow);</b>
<i>2259</i>&nbsp;        }
<b class="nc"><i>2260</i>&nbsp;    }</b>
<i>2261</i>&nbsp;
<i>2262</i>&nbsp;    private void forward() {
<b class="nc"><i>2263</i>&nbsp;        if (!nextEntries.isEmpty()) {</b>
<b class="nc"><i>2264</i>&nbsp;            BibEntry toShow = nextEntries.get(nextEntries.size() - 1);</b>
<b class="nc"><i>2265</i>&nbsp;            nextEntries.remove(nextEntries.size() - 1);</b>
<i>2266</i>&nbsp;            // Add the entry we are going forward from to the Back history:
<b class="nc"><i>2267</i>&nbsp;            if (showing != null) {</b>
<b class="nc"><i>2268</i>&nbsp;                previousEntries.add(showing);</b>
<i>2269</i>&nbsp;            }
<b class="nc"><i>2270</i>&nbsp;            backOrForwardInProgress = true; // to avoid the history getting updated erroneously</b>
<b class="nc"><i>2271</i>&nbsp;            highlightEntry(toShow);</b>
<i>2272</i>&nbsp;        }
<b class="nc"><i>2273</i>&nbsp;    }</b>
<i>2274</i>&nbsp;
<i>2275</i>&nbsp;    public void setBackAndForwardEnabledState() {
<b class="nc"><i>2276</i>&nbsp;        frame.getBackAction().setEnabled(!previousEntries.isEmpty());</b>
<b class="nc"><i>2277</i>&nbsp;        frame.getForwardAction().setEnabled(!nextEntries.isEmpty());</b>
<b class="nc"><i>2278</i>&nbsp;    }</b>
<i>2279</i>&nbsp;
<i>2280</i>&nbsp;    private String formatOutputMessage(String start, int count) {
<b class="nc"><i>2281</i>&nbsp;        return String.format(&quot;%s %d %s.&quot;, start, count,</b>
<b class="nc"><i>2282</i>&nbsp;                (count &gt; 1 ? Localization.lang(&quot;entries&quot;) : Localization.lang(&quot;entry&quot;)));</b>
<i>2283</i>&nbsp;    }
<i>2284</i>&nbsp;
<i>2285</i>&nbsp;
<i>2286</i>&nbsp;    private class SaveSelectedAction implements BaseAction {
<i>2287</i>&nbsp;
<i>2288</i>&nbsp;        private final SavePreferences.DatabaseSaveType saveType;
<i>2289</i>&nbsp;
<b class="nc"><i>2290</i>&nbsp;        public SaveSelectedAction(SavePreferences.DatabaseSaveType saveType) {</b>
<b class="nc"><i>2291</i>&nbsp;            this.saveType = saveType;</b>
<b class="nc"><i>2292</i>&nbsp;        }</b>
<i>2293</i>&nbsp;
<i>2294</i>&nbsp;        @Override
<i>2295</i>&nbsp;        public void action() throws SaveException {
<b class="nc"><i>2296</i>&nbsp;            FileDialog dialog = new FileDialog(frame).withExtension(FileExtensions.BIBTEX_DB);</b>
<b class="nc"><i>2297</i>&nbsp;            dialog.setDefaultExtension(FileExtensions.BIBTEX_DB);</b>
<b class="nc"><i>2298</i>&nbsp;            Optional&lt;Path&gt; chosenFile = dialog.saveNewFile();</b>
<i>2299</i>&nbsp;
<b class="nc"><i>2300</i>&nbsp;            if (chosenFile.isPresent()) {</b>
<b class="nc"><i>2301</i>&nbsp;                Path path = chosenFile.get();</b>
<b class="nc"><i>2302</i>&nbsp;                saveDatabase(path.toFile(), true, Globals.prefs.getDefaultEncoding(), saveType);</b>
<b class="nc"><i>2303</i>&nbsp;                frame.getFileHistory().newFile(path.toString());</b>
<b class="nc"><i>2304</i>&nbsp;                frame.output(Localization.lang(&quot;Saved selected to &#39;%0&#39;.&quot;, path.toString()));</b>
<i>2305</i>&nbsp;            }
<b class="nc"><i>2306</i>&nbsp;        }</b>
<i>2307</i>&nbsp;    }
<i>2308</i>&nbsp;
<i>2309</i>&nbsp;    private static class SearchAndOpenFile {
<i>2310</i>&nbsp;        private final BibEntry entry;
<i>2311</i>&nbsp;        private final BasePanel basePanel;
<i>2312</i>&nbsp;
<b class="nc"><i>2313</i>&nbsp;        public SearchAndOpenFile(final BibEntry entry, final BasePanel basePanel) {</b>
<b class="nc"><i>2314</i>&nbsp;            this.entry = entry;</b>
<b class="nc"><i>2315</i>&nbsp;            this.basePanel = basePanel;</b>
<b class="nc"><i>2316</i>&nbsp;        }</b>
<i>2317</i>&nbsp;
<i>2318</i>&nbsp;        public Optional&lt;String&gt; searchAndOpen() {
<b class="nc"><i>2319</i>&nbsp;            if (!Globals.prefs.getBoolean(JabRefPreferences.RUN_AUTOMATIC_FILE_SEARCH)) {</b>
<b class="nc"><i>2320</i>&nbsp;                return Optional.empty();</b>
<i>2321</i>&nbsp;            }
<i>2322</i>&nbsp;
<i>2323</i>&nbsp;            /*  The search can lead to an unexpected 100% CPU usage which is perceived
<i>2324</i>&nbsp;                as a bug, if the search incidentally starts at a directory with lots
<i>2325</i>&nbsp;                of stuff below. It is now disabled by default. */
<i>2326</i>&nbsp;
<i>2327</i>&nbsp;            // see if we can fall back to a filename based on the bibtex key
<b class="nc"><i>2328</i>&nbsp;            final List&lt;BibEntry&gt; entries = Collections.singletonList(entry);</b>
<i>2329</i>&nbsp;
<b class="nc"><i>2330</i>&nbsp;            final Set&lt;ExternalFileType&gt; types = ExternalFileTypes.getInstance().getExternalFileTypeSelection();</b>
<b class="nc"><i>2331</i>&nbsp;            final List&lt;File&gt; dirs = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>2332</i>&nbsp;            final List&lt;String&gt; mdDirs = basePanel.getBibDatabaseContext()</b>
<b class="nc"><i>2333</i>&nbsp;                    .getFileDirectories(Globals.prefs.getFileDirectoryPreferences());</b>
<b class="nc"><i>2334</i>&nbsp;            for (final String mdDir : mdDirs) {</b>
<b class="nc"><i>2335</i>&nbsp;                dirs.add(new File(mdDir));</b>
<b class="nc"><i>2336</i>&nbsp;            }</b>
<b class="nc"><i>2337</i>&nbsp;            final List&lt;String&gt; extensions = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>2338</i>&nbsp;            for (final ExternalFileType type : types) {</b>
<b class="nc"><i>2339</i>&nbsp;                extensions.add(type.getExtension());</b>
<b class="nc"><i>2340</i>&nbsp;            }</b>
<i>2341</i>&nbsp;            // Run the search operation:
<i>2342</i>&nbsp;            Map&lt;BibEntry, List&lt;File&gt;&gt; result;
<b class="nc"><i>2343</i>&nbsp;            if (Globals.prefs.getBoolean(JabRefPreferences.AUTOLINK_USE_REG_EXP_SEARCH_KEY)) {</b>
<b class="nc"><i>2344</i>&nbsp;                String regExp = Globals.prefs.get(JabRefPreferences.REG_EXP_SEARCH_EXPRESSION_KEY);</b>
<b class="nc"><i>2345</i>&nbsp;                result = RegExpFileSearch.findFilesForSet(entries, extensions, dirs, regExp,</b>
<b class="nc"><i>2346</i>&nbsp;                        Globals.prefs.getKeywordDelimiter());</b>
<b class="nc"><i>2347</i>&nbsp;            } else {</b>
<b class="nc"><i>2348</i>&nbsp;                boolean autoLinkExactKeyOnly = Globals.prefs.getBoolean(JabRefPreferences.AUTOLINK_EXACT_KEY_ONLY);</b>
<b class="nc"><i>2349</i>&nbsp;                result = FileUtil.findAssociatedFiles(entries, extensions, dirs, autoLinkExactKeyOnly);</b>
<i>2350</i>&nbsp;            }
<b class="nc"><i>2351</i>&nbsp;            if (result.containsKey(entry)) {</b>
<b class="nc"><i>2352</i>&nbsp;                final List&lt;File&gt; res = result.get(entry);</b>
<b class="nc"><i>2353</i>&nbsp;                if (!res.isEmpty()) {</b>
<b class="nc"><i>2354</i>&nbsp;                    final String filepath = res.get(0).getPath();</b>
<b class="nc"><i>2355</i>&nbsp;                    final Optional&lt;String&gt; extension = FileUtil.getFileExtension(filepath);</b>
<b class="nc"><i>2356</i>&nbsp;                    if (extension.isPresent()) {</b>
<b class="nc"><i>2357</i>&nbsp;                        Optional&lt;ExternalFileType&gt; type = ExternalFileTypes.getInstance()</b>
<b class="nc"><i>2358</i>&nbsp;                                .getExternalFileTypeByExt(extension.get());</b>
<b class="nc"><i>2359</i>&nbsp;                        if (type.isPresent()) {</b>
<i>2360</i>&nbsp;                            try {
<b class="nc"><i>2361</i>&nbsp;                                JabRefDesktop.openExternalFileAnyFormat(basePanel.getBibDatabaseContext(), filepath,</b>
<i>2362</i>&nbsp;                                        type);
<b class="nc"><i>2363</i>&nbsp;                                basePanel.output(Localization.lang(&quot;External viewer called&quot;) + &#39;.&#39;);</b>
<b class="nc"><i>2364</i>&nbsp;                                return Optional.of(filepath);</b>
<b class="nc"><i>2365</i>&nbsp;                            } catch (IOException ex) {</b>
<b class="nc"><i>2366</i>&nbsp;                                basePanel.output(Localization.lang(&quot;Error&quot;) + &quot;: &quot; + ex.getMessage());</b>
<i>2367</i>&nbsp;                            }
<i>2368</i>&nbsp;                        }
<i>2369</i>&nbsp;                    }
<i>2370</i>&nbsp;                }
<i>2371</i>&nbsp;            }
<i>2372</i>&nbsp;
<b class="nc"><i>2373</i>&nbsp;            return Optional.empty();</b>
<i>2374</i>&nbsp;        }
<i>2375</i>&nbsp;    }
<i>2376</i>&nbsp;
<i>2377</i>&nbsp;    /**
<i>2378</i>&nbsp;     * This method iterates through all existing entry editors in this BasePanel, telling each to update all its
<i>2379</i>&nbsp;     * instances of FieldContentSelector. This is done to ensure that the list of words in each selector is up-to-date
<i>2380</i>&nbsp;     * after the user has made changes in the Manage dialog.
<i>2381</i>&nbsp;     */
<i>2382</i>&nbsp;    public void updateAllContentSelectors() {
<b class="nc"><i>2383</i>&nbsp;        currentEditor.updateAllContentSelectors();</b>
<b class="nc"><i>2384</i>&nbsp;    }</b>
<i>2385</i>&nbsp;
<i>2386</i>&nbsp;    /**
<i>2387</i>&nbsp;     * Set the preview active state for all BasePanel instances.
<i>2388</i>&nbsp;     *
<i>2389</i>&nbsp;     * @param enabled
<i>2390</i>&nbsp;     */
<i>2391</i>&nbsp;    private void setPreviewActiveBasePanels(boolean enabled) {
<b class="nc"><i>2392</i>&nbsp;        for (int i = 0; i &lt; frame.getTabbedPane().getTabCount(); i++) {</b>
<b class="nc"><i>2393</i>&nbsp;            frame.getBasePanelAt(i).setPreviewActive(enabled);</b>
<i>2394</i>&nbsp;        }
<b class="nc"><i>2395</i>&nbsp;    }</b>
<i>2396</i>&nbsp;
<i>2397</i>&nbsp;    public CountingUndoManager getUndoManager() {
<b class="nc"><i>2398</i>&nbsp;        return undoManager;</b>
<i>2399</i>&nbsp;    }
<i>2400</i>&nbsp;
<i>2401</i>&nbsp;    public MainTable getMainTable() {
<b class="nc"><i>2402</i>&nbsp;        return mainTable;</b>
<i>2403</i>&nbsp;    }
<i>2404</i>&nbsp;
<i>2405</i>&nbsp;    public BibDatabaseContext getDatabaseContext() {
<b class="nc"><i>2406</i>&nbsp;        return bibDatabaseContext;</b>
<i>2407</i>&nbsp;    }
<i>2408</i>&nbsp;
<i>2409</i>&nbsp;    public Optional&lt;SearchQuery&gt; getCurrentSearchQuery() {
<b class="nc"><i>2410</i>&nbsp;        return currentSearchQuery;</b>
<i>2411</i>&nbsp;    }
<i>2412</i>&nbsp;
<i>2413</i>&nbsp;    /**
<i>2414</i>&nbsp;     * Set the query the user currently searches while this basepanel is active
<i>2415</i>&nbsp;     * @param currentSearchQuery can be null
<i>2416</i>&nbsp;     */
<i>2417</i>&nbsp;    public void setCurrentSearchQuery(SearchQuery currentSearchQuery) {
<b class="nc"><i>2418</i>&nbsp;        this.currentSearchQuery = Optional.ofNullable(currentSearchQuery);</b>
<b class="nc"><i>2419</i>&nbsp;    }</b>
<i>2420</i>&nbsp;
<i>2421</i>&nbsp;    public CitationStyleCache getCitationStyleCache() {
<b class="nc"><i>2422</i>&nbsp;        return citationStyleCache;</b>
<i>2423</i>&nbsp;    }
<i>2424</i>&nbsp;
<i>2425</i>&nbsp;    public PreviewPanel getPreviewPanel() {
<b class="nc"><i>2426</i>&nbsp;        if (selectionListener == null) {</b>
<i>2427</i>&nbsp;            // only occurs if this is called while instantiating this BasePanel
<b class="nc"><i>2428</i>&nbsp;            return null;</b>
<i>2429</i>&nbsp;        }
<b class="nc"><i>2430</i>&nbsp;        return selectionListener.getPreview();</b>
<i>2431</i>&nbsp;    }
<i>2432</i>&nbsp;
<i>2433</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2017-07-15 00:44</div>
</div>
</body>
</html>
